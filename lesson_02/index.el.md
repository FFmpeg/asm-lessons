**Μάθημα Δεύτερο Γλώσσας Assembly του FFmpeg**

Τώρα που γράψατε την πρώτη σας συνάρτηση σε γλώσσα assembly, θα εισαγάγουμε τις διακλαδώσεις (branches) και τους βρόχους (loops).

Πρέπει πρώτα να εισαγάγουμε την ιδέα των ετικετών (labels) και των αλμάτων (jumps). Στο τεχνητό παράδειγμα παρακάτω, η εντολή jmp μετακινεί την εκτέλεση του κώδικα μετά το «.loop:». Το «.loop:» είναι γνωστό ως *ετικέτα* (label), με το πρόθεμα της τελείας να σημαίνει ότι είναι μια *τοπική ετικέτα* (local label), επιτρέποντάς σας ουσιαστικά να επαναχρησιμοποιήσετε το ίδιο όνομα ετικέτας σε πολλαπλές συναρτήσεις. Αυτό το παράδειγμα, φυσικά, δείχνει έναν ατέρμονα βρόχο, αλλά θα το επεκτείνουμε αργότερα σε κάτι πιο ρεαλιστικό.

```assembly
mov  r0q, 3
.loop:
    dec  r0q
    jmp .loop
```

Πριν δημιουργήσουμε έναν ρεαλιστικό βρόχο, πρέπει να εισαγάγουμε τον καταχωρητή *FLAGS*. Δεν θα σταθούμε πολύ στις περιπλοκές του *FLAGS* (πάλι επειδή οι λειτουργίες GPR είναι σε μεγάλο βαθμό σκαλωσιές), αλλά υπάρχουν αρκετές σημαίες (flags) όπως η Zero-Flag (Σημαία Μηδενός), η Sign-Flag (Σημαία Προσήμου) και η Overflow-Flag (Σημαία Υπερχείλισης), οι οποίες ορίζονται με βάση το αποτέλεσμα των περισσότερων εντολών εκτός της mov σε βαθμωτά δεδομένα, όπως αριθμητικές πράξεις και μετατοπίσεις.

Ακολουθεί ένα παράδειγμα όπου ο μετρητής του βρόχου μετρά αντίστροφα μέχρι το μηδέν και η jg (άλμα αν είναι μεγαλύτερο από το μηδέν) είναι η συνθήκη του βρόχου. Η dec r0q θέτει τις σημαίες (FLAGs) με βάση την τιμή του r0q μετά την εντολή και μπορείτε να κάνετε άλμα με βάση αυτές.

```assembly
mov  r0q, 3
.loop:
    ; κάνε κάτι
    dec  r0q
    jg  .loop ; άλμα αν είναι μεγαλύτερο από το μηδέν
```

Αυτό είναι ισοδύναμο με τον ακόλουθο κώδικα C:

```c
int i = 3;
do
{
   // κάνε κάτι
   i--;
} while(i > 0)
```

Αυτός ο κώδικας C είναι λίγο αφύσικος. Συνήθως ένας βρόχος σε C γράφεται ως εξής:

```c
int i;
for(i = 0; i < 3; i++) {
    // κάνε κάτι
}
```

Αυτό είναι περίπου ισοδύναμο με (δεν υπάρχει απλός τρόπος να αντιστοιχιστεί αυτός ο βρόχος ```for```):

```assembly
xor r0q, r0q
.loop:
    ; κάνε κάτι
    inc r0q
    cmp r0q, 3
    jl  .loop ; άλμα αν (r0q - 3) < 0, δηλαδή (r0q < 3)
```

Υπάρχουν πολλά πράγματα που πρέπει να επισημανθούν σε αυτό το απόσπασμα. Το πρώτο είναι το ```xor r0q, r0q```, που είναι ένας συνηθισμένος τρόπος για να μηδενίσετε έναν καταχωρητή, ο οποίος σε ορισμένα συστήματα είναι ταχύτερος από το ```mov r0q, 0```, επειδή, με απλά λόγια, δεν πραγματοποιείται πραγματική φόρτωση (load). Μπορεί επίσης να χρησιμοποιηθεί σε καταχωρητές SIMD με ```pxor m0, m0``` για να μηδενίσει έναν ολόκληρο καταχωρητή. Το επόμενο πράγμα που πρέπει να σημειωθεί είναι η χρήση της cmp. Η cmp ουσιαστικά αφαιρεί τον δεύτερο καταχωρητή από τον πρώτο (χωρίς να αποθηκεύει την τιμή πουθενά) και θέτει τις FLAGS, αλλά σύμφωνα με το σχόλιο, μπορεί να διαβαστεί μαζί με το άλμα, (jl = άλμα αν είναι μικρότερο από το μηδέν) για να γίνει άλμα εάν ```r0q < 3```.

Παρατηρήστε πώς υπάρχει μια επιπλέον εντολή (cmp) σε αυτό το απόσπασμα. Γενικά μιλώντας, λιγότερες εντολές σημαίνουν ταχύτερο κώδικα, γι' αυτό και προτιμάται το προηγούμενο απόσπασμα. Όπως θα δείτε σε μελλοντικά μαθήματα, υπάρχουν περισσότερα κόλπα που χρησιμοποιούνται για την αποφυγή αυτής της επιπλέον εντολής και για τον ορισμό των FLAGS από μια αριθμητική ή άλλη πράξη. Σημειώστε πώς δεν γράφουμε assembly για να ταιριάζει ακριβώς με τους βρόχους της C, γράφουμε βρόχους για να τους κάνουμε όσο το δυνατόν γρηγορότερους στην assembly.

Ακολουθούν ορισμένα συνηθισμένα μνημονικά άλματος που θα καταλήξετε να χρησιμοποιείτε (οι *FLAGS* παρατίθενται για πληρότητα, αλλά δεν χρειάζεται να γνωρίζετε τις λεπτομέρειες για να γράψετε βρόχους):

| Mnemonic | Description  | FLAGS |
| :---- | :---- | :---- |
| JE/JZ | Άλμα αν Ίσο/Μηδέν | ZF = 1 |
| JNE/JNZ | Άλμα αν Όχι Ίσο/Όχι Μηδέν | ZF = 0 |
| JG/JNLE | Άλμα αν Μεγαλύτερο/Όχι Μικρότερο ή Ίσο (προσημασμένο) | ZF = 0 and SF = OF |
| JGE/JNL | Άλμα αν Μεγαλύτερο ή Ίσο/Όχι Μικρότερο (προσημασμένο) | SF = OF |
| JL/JNGE | Άλμα αν Μικρότερο/Όχι Μεγαλύτερο ή Ίσο (προσημασμένο) | SF ≠ OF |
| JLE/JNG | Άλμα αν Μικρότερο ή Ίσο/Όχι Μεγαλύτερο (προσημασμένο) | ZF = 1 or SF ≠ OF |

**Σταθερές**

Ας δούμε μερικά παραδείγματα που δείχνουν πώς να χρησιμοποιούμε σταθερές:

```assembly
SECTION_RODATA

constants_1: db 1,2,3,4
constants_2: times 2 dw 4,3,2,1
```

* SECTION_RODATA καθορίζει ότι πρόκειται για ένα τμήμα δεδομένων μόνο για ανάγνωση (read-only data section). (Αυτή είναι μια μακροεντολή επειδή διαφορετικές μορφές αρχείων εξόδου που χρησιμοποιούν τα λειτουργικά συστήματα το δηλώνουν διαφορετικά)
* constants_1: Η ετικέτα constants_1, ορίζεται ως ```db``` (declare byte - δήλωση byte) - δηλαδή ισοδύναμο με το uint8_t constants_1[4] = {1, 2, 3, 4};
* constants_2: Αυτό χρησιμοποιεί τη μακροεντολή ```times 2``` για να επαναλάβει τις δηλωμένες λέξεις - δηλαδή ισοδύναμο με το uint16_t constants_2[8] = {4, 3, 2, 1, 4, 3, 2, 1};

Αυτές οι ετικέτες, τις οποίες ο assembler μετατρέπει σε μια διεύθυνση μνήμης, μπορούν στη συνέχεια να χρησιμοποιηθούν σε φορτώσεις (loads) (αλλά όχι σε αποθηκεύσεις (stores) καθώς είναι μόνο για ανάγνωση). Ορισμένες εντολές δέχονται μια διεύθυνση μνήμης ως τελεστέο, οπότε μπορούν να χρησιμοποιηθούν χωρίς ρητές φορτώσεις σε έναν καταχωρητή (υπάρχουν πλεονεκτήματα και μειονεκτήματα σε αυτό).

**Μετατοπίσεις (Offsets)**

Οι μετατοπίσεις είναι η απόσταση (σε bytes) μεταξύ διαδοχικών στοιχείων στη μνήμη. Η μετατόπιση καθορίζεται από το **μέγεθος κάθε στοιχείου** στη δομή δεδομένων.

Τώρα που μπορούμε να γράφουμε βρόχους, ήρθε η ώρα να ανακτήσουμε δεδομένα. Αλλά υπάρχουν μερικές διαφορές σε σύγκριση με τη C. Ας δούμε τον ακόλουθο βρόχο σε C:

```c
uint32_t data[3];
int i;
for(i = 0; i < 3; i++) {
    data[i];
}
```

Η μετατόπιση των 4-byte μεταξύ των στοιχείων των δεδομένων προϋπολογίζεται από τον μεταγλωττιστή της C. Αλλά όταν γράφετε assembly χειροκίνητα, πρέπει να υπολογίσετε αυτές τις μετατοπίσεις μόνοι σας.

Ας δούμε τη σύνταξη για τους υπολογισμούς διευθύνσεων μνήμης. Αυτό ισχύει για όλους τους τύπους διευθύνσεων μνήμης:

```assembly
[base + scale*index + disp]
```

* base - Αυτός είναι ένας GPR (συνήθως ένας δείκτης από ένα όρισμα συνάρτησης C)
* scale - Αυτό μπορεί να είναι 1, 2, 4, 8. Το 1 είναι η προεπιλογή
* index - Αυτός είναι ένας GPR (συνήθως ένας μετρητής βρόχου)
* disp - Αυτός είναι ένας ακέραιος (έως 32-bit). Η μετατόπιση (Displacement) είναι μια απόκλιση (offset) μέσα στα δεδομένα

Η x86asm παρέχει τη σταθερά mmsize, η οποία σας επιτρέπει να γνωρίζετε το μέγεθος του καταχωρητή SIMD με τον οποίο εργάζεστε.

Ακολουθεί ένα απλό (και χωρίς νόημα) παράδειγμα για να απεικονίσει τη φόρτωση από προσαρμοσμένες μετατοπίσεις:

```assembly
;static void simple_loop(const uint8_t *src)
INIT_XMM sse2
cglobal simple_loop, 1, 2, 2, src
     movq r1q, 3
.loop:
     movu m0, [srcq]
     movu m1, [srcq+2*r1q+3+mmsize]

     ; κάνε κάποια πράγματα

     add srcq, mmsize
dec r1q
jg .loop

RET
```

Σημειώστε πώς στο ```movu m1, [srcq+2*r1q+3+mmsize]``` ο assembler θα προϋπολογίσει τη σωστή σταθερά μετατόπισης (displacement constant) που θα χρησιμοποιηθεί. Στο επόμενο μάθημα θα σας δείξουμε ένα κόλπο για να αποφύγετε να κάνετε add και dec στον βρόχο, αντικαθιστώντας τα με ένα μόνο add.

**LEA**

Τώρα που καταλαβαίνετε τις μετατοπίσεις (offsets), μπορείτε να χρησιμοποιήσετε την εντολή lea (Load Effective Address - Φόρτωση Ενεργής Διεύθυνσης). Αυτό σας επιτρέπει να εκτελέσετε πολλαπλασιασμό και πρόσθεση με μία μόνο εντολή, κάτι που θα είναι ταχύτερο από τη χρήση πολλαπλών εντολών. Υπάρχουν, φυσικά, περιορισμοί σχετικά με το με τι μπορείτε να πολλαπλασιάσετε και να προσθέσετε, αλλά αυτό δεν εμποδίζει την lea από το να είναι μια ισχυρή εντολή.

```assembly
lea r0q, [base + scale*index + disp]
```

Αντίθετα με το όνομά της, η LEA μπορεί να χρησιμοποιηθεί για κανονική αριθμητική καθώς και για υπολογισμούς διευθύνσεων. Μπορείτε να κάνετε κάτι τόσο περίπλοκο όσο:

```assembly
lea r0q, [r1q + 8*r2q + 5]
```

Σημειώστε ότι αυτό δεν επηρεάζει τα περιεχόμενα των r1q και r2q. Επίσης, δεν επηρεάζει τις FLAGS (οπότε δεν μπορείτε να κάνετε άλμα με βάση το αποτέλεσμα). Η χρήση της LEA αποφεύγει όλες αυτές τις εντολές και τους προσωρινούς καταχωρητές (αυτός ο κώδικας δεν είναι ισοδύναμος επειδή η add αλλάζει τις *FLAGS*):

```assembly
movq r0q, r1q
movq r3q, r2q
sal  r3q, 3 ; αριθμητική ολίσθηση αριστερά 3 = * 8
add  r3q, 5
add  r0q, r3q
```

Θα δείτε την lea να χρησιμοποιείται συχνά για τη ρύθμιση διευθύνσεων πριν από βρόχους ή για την εκτέλεση υπολογισμών όπως ο παραπάνω. Σημειώστε φυσικά, ότι δεν μπορείτε να κάνετε όλους τους τύπους πολλαπλασιασμού και πρόσθεσης, αλλά οι πολλαπλασιασμοί με 1, 2, 4, 8 και η πρόσθεση μιας σταθερής μετατόπισης είναι συνηθισμένοι.

Στην εργασία θα πρέπει να φορτώσετε μια σταθερά και να προσθέσετε τις τιμές σε ένα διάνυσμα SIMD μέσα σε έναν βρόχο.

[Επόμενο Μάθημα](../lesson_03/index.el.md)