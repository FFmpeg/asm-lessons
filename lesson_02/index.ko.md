# FFmpeg 어셈블리어 강의 2강

첫 번째 어셈블리어 함수를 작성해 보았습니다. 이번에는 분기(branch)와 반복문(loop)을 소개하겠습니다.

먼저 레이블과 점프(jump)의 개념을 알아야 합니다. 아래의 예제에서 `jmp` 명령어는 코드 실행을 `.loop:` 뒤로 이동시킵니다. `.loop:`는 **레이블**이라 부르며, 레이블 앞에 붙은 점(`.`)은 이것이 로컬 레이블(local label)임을 나타냅니다. 로컬 레이블을 사용하면 여러 함수에서 동일한 레이블을 재사용할 수 있습니다.

아래는 무한 루프의 예제입니다. 이후 이를 좀 더 현실적인 예시로 확장할 것입니다.

```assembly
mov  r0q, 3
.loop:
    dec  r0q
    jmp .loop
```

더욱 현실적인 반복문을 만들기 전에 FLAGS 레지스터를 알아보겠습니다. FLAGS의 세부 동작에 대해서는 깊게 다루지 않겠습니다(앞서 설명했듯이 GPR 연산은 주로 보조 역할이기 때문입니다). 다만, 산술 연산이나 시프트처럼 스칼라 데이터에 대해 `mov` 이외의 대부분의 명령을 실행하면 **Zero-Flag**, **Sign-Flag**, **Overflow-Flag**와 같은 여러 플래그가 설정됩니다.

다음은 루프 카운터가 0까지 감소하도록 하고, `jg`(0보다 크면 점프)가 반복 조건이 되는 예시입니다. `dec r0q` 명령은 실행 후 `r0q` 값에 따라 플래그들을 설정하며, 이 플래그를 바탕으로 점프할 수 있습니다.

```assembly
mov  r0q, 3
.loop:
    ; ...
    dec  r0q
    jg  .loop ; 0보다 크면 점프
```

이는 다음 C 코드와 동일합니다.

```c
int i = 3;
do
{
   // ...
   i--;
} while(i > 0)
```

이 코드는 약간 부자연스럽습니다. 일반적인 C코드의 반복문은 다음과 같이 작성합니다.

```c
int i;
for(i = 0; i < 3; i++) {
    // ...
}
```

이 `for` 루프와 동일하게 대응시키는 방법은 없지만, 대략 다음 어셈블리 코드와 비슷합니다.

```assembly
xor r0q, r0q
.loop:
    ; ...
    inc r0q
    cmp r0q, 3
    jl  .loop ; jump if (r0q - 3) < 0, i.e (r0q < 3)
```

이 코드 조각에서 주목해야 할 점이 몇 가지 있습니다.

첫째, `xor r0q, r0q`는 레지스터를 0으로 만드는 흔한 방법입니다. 일부 시스템에서는 `mov r0q, 0`보다 더 빠를 수 있는데, 간단히 설명하면 실제 메모리 로드 동작이 일어나지 않기 때문입니다. 이 방식은 SIMD 레지스터에서도 사용할 수 있으며, 예를 들어 `pxor m0, m0`[^1]는 전체 레지스터를 0으로 초기화합니다.

둘째, `cmp`의 사용입니다. `cmp`는 첫 번째 피연산자에서 두 번째 피연산자를 뺀 값을 어디에도 저장하지 않고, 그 결과에 따라 FLAGS를 설정합니다. 주석의 내용처럼 점프 명령과 함께 읽어야 하며, `jl`(jump if less than zero)는 `r0q < 3`일 때 점프하게 됩니다.

또한 이 코드에는 추가 명령어(`cmp`)가 하나 더 있다는 점을 유의해야 합니다. 일반적으로 명령어 수가 적을수록 코드가 더 빠르므로 이전 예제의 방식이 더 선호됩니다. 앞으로의 강의에서 보겠지만, 이러한 추가 명령을 피하고 산술 연산이나 다른 연산에서 바로 FLAGS를 설정하는 다양한 기법들이 있습니다.

마지막으로, C의 반복문을 어셈블리 코드에서 정확히 동일하게 재현하려는 것이 아닌, 가능한 한 빠르게 동작하는 반복문을 작성하는 것이 목적이라는 것을 기억해야 합니다.

다음은 자주 사용하게 될 몇 가지 점프 명령어 약어입니다(*FLAGS*는 참고를 위해 추가했으며 루프를 작성하는데 세부 내용을 반드시 알 필요는 없습니다).

| 니모닉(Mnemonic) | 설명  | FLAGS |
| :---- | :---- | :---- |
| `JE`/`JZ` | 같음 / 0일 때 점프 | ZF = 1 |
| `JNE`/`JNZ` | 같지 않음 / 0이 아닐 때 점프 | ZF = 0 |
| `JG`/`JNLE` | 큼 / 작거나 같지 않음(부호 있는 비교)일 때 점프 | ZF = 0 그리고 SF = OF |
| `JGE`/`JNL` | 크거나 같음 / 작지 않음(부호 있는 비교)일 때 점프 | SF = OF |
| `JL`/`JNGE` | 작음 / 크거나 같지않음(부호 있는 비교)일 때 점프 | SF ≠ OF |
| `JLE`/`JNG` | 작거나 같음 / 크지 않음(부호 있는 비교)일 때 점프 | ZF = 1 또는 SF ≠ OF |

## 상수(Constants)

다음은 상수를 사용하는 예시입니다.

```assembly
SECTION_RODATA

constants_1: db 1,2,3,4
constants_2: times 2 dw 4,3,2,1
```

* `SECTION_RODATA`는 읽기 전용 데이터 섹션임을 지정합니다. (운영체제가 사용하는 출력 파일 형식마다 선언 방식이 다르므로 매크로로 정의되어 있음)
* `constants_1`: `db`(declare byte)로 정의된 `constants_1` 레이블로, `uint8_t constants_1[4] = {1, 2, 3, 4};`와 동일합니다.
* `constants_2`: `times 2` 매크로를 이용해 선언된 워드를 두 번 반복합니다. `uint16_t constants_2[8] = {4, 3, 2, 1, 4, 3, 2, 1};`과 동일합니다.

이러한 레이블들은 어셈블러에 의해 메모리 주소로 변환됩니다. 읽기 전용이기 때문에 로드(load) 연산에는 사용할 수 있지만 저장(store) 연산에는 사용할 수 없습니다. 일부 명령어는 메모리 주소를 직접 피연산자로 받을 수 있어, 레지스터에 명시적으로 로드하지 않고도 메모리에 직접 접근할 수 있습니다(이 방식에는 장단점이 있습니다).

## 오프셋(Offset)

오프셋이란 메모리에서 연속된 요소 간의 거리(바이트 단위)를 말하며, 자료 구조의 각 요소 크기에 따라 결정됩니다.

이제 반복문을 작성할 수 있게 되었고, 데이터를 읽어볼 차례입니다. 다만 C언어와는 다른 점이 있습니다.

C 코드 예시를 살펴보겠습니다.

```c
uint32_t data[3];
int i;
for(i = 0; i < 3; i++) {
    data[i];
}
```

C 컴파일러는 `data`의 각 요소가 차지하는 4바이트 오프셋을 미리 계산합니다. 그러나 어셈블리 코드를 직접 작성할 때는 오프셋을 직접 계산해야 합니다.

모든 메모리 주소 계산에 적용되는 구문은 다음과 같습니다.

```assembly
[base + scale*index + disp]
```

* **base** - GPR(일반적으로 C 함수 인자로 받은 포인터)
* **scale** - 1, 2, 4, 8 중 하나 (기본값: 1)
* **index** - GPR(보통 루프 카운터)
* **disp** - 32비트 정수. 데이터 내부의 오프셋(변위, displacement)

x86 어셈블리는 현재 사용 중인 SIMD 레지스터 크기를 알려주는 `mmsize` 상수를 제공합니다.

<!-- 원문에서는 nonsensical이라는 사족이 있지만, '단순'과 의미가 비슷하기 때문에 따로 옮기지는 않았습니다 -->
다음은 사용자 지정 오프셋에서 값을 읽어오는 간단한 예시입니다.

```assembly
;static void simple_loop(const uint8_t *src)
INIT_XMM sse2
cglobal simple_loop, 1, 2, 2, src
     movq r1q, 3
.loop:
     movu m0, [srcq]
     movu m1, [srcq+2*r1q+3+mmsize]

     ; ...

     add srcq, mmsize
dec r1q
jg .loop

RET
```

`movu m1, [srcq+2*r1q+3+mmsize]`에서 어셈블러가 사용할 올바른 변위 상수(displacement constant)를 미리 계산해 준다는 점을 주목해 보세요. 다음 강의에서는 루프 내에서 `add`와 `dec` 두 연산을 사용하는 대신, 하나의 `add` 연산만 사용하는 방법을 보여드리겠습니다.

## LEA (Load Effective Address)

오프셋 개념을 이해했다면 이제 `lea` 명령어를 사용할 수 있습니다. `lea`는 한 번의 명령으로 곱셈과 덧셈을 수행할 수 있어 여러 명령을 사용하는 것보다 빠릅니다. 곱하거나 더할 수 있는 값에는 제한이 있지만, 여전히 강력한 명령입니다.

```assembly
lea r0q, [base + scale*index + disp]
```

이름과 달리 `lea`는 주소 계산뿐 아니라 일반 산술 연산에도 사용할 수 있습니다. 예를 들어,

```assembly
lea r0q, [r1q + 8*r2q + 5]
```

이 명령어는 `r1q`와 `r2q`의 값을 변경하지 않으며, FLAGS도 변경하지 않습니다(즉, 결과를 기반으로 한 점프가 불가능합니다). `lea`를 사용하면 여러 명령어와 임시 레지스터 사용을 피할 수 있습니다. 단, 아래 코드는 `add`가 FLAGS를 변경하기 때문에 완전히 동일하지는 않습니다.

```assembly
movq r0q, r1q
movq r3q, r2q
sal  r3q, 3 ; 왼쪽으로 3비트 산술 시프트 = * 8
add  r3q, 5
add  r0q, r3q
```

`lea`는 루프 전에 주소를 설정하거나 위와 같은 계산을 할 때 자주 사용됩니다. 모든 곱셈과 덧셈을 수행할 수는 없지만, 1·2·4·8배 곱셈과 고정 오프셋 곱셈은 매우 흔한 연산입니다.

과제에서는 상수를 로드하고, 루프 내에서 그 값을 SIMD 벡터에 더하는 작업을 수행하게 됩니다.

[다음 강의](../lesson_03/index.md)

[^1]: `pxor`은 *Packed XOR*의 줄임말로 두 개의 SIMD 레지스터나 메모리 위치에 있는 데이터에 대해 비트별 XOR 연산을 병렬로 수행합니다.
