**Μάθημα Πρώτο Γλώσσας Assembly του FFmpeg**

**Εισαγωγή**

Καλώς ήρθατε στη Σχολή Γλώσσας Assembly της FFmpeg. Έχετε κάνει το πρώτο βήμα σε ένα από τα πιο ενδιαφέροντα, απαιτητικά και ικανοποιητικά ταξίδια στον κόσμο του προγραμματισμού. Αυτά τα μαθήματα θα σας δώσουν τις βασικές γνώσεις για τον τρόπο με τον οποίο γράφεται η γλώσσα Assembly στο FFmpeg και θα σας ανοίξει τα μάτια για το τι πραγματικά συμβαίνει στον υπολογιστή σας.

**Απαιτούμενες γνώσεις**

* Γνώση της γλώσσας C, ιδίως των δεικτών. Αν δεν γνωρίζετε C, μελετήστε το βιβλίο [The C Programming Language](https://en.wikipedia.org/wiki/The_C_Programming_Language)  
* Μαθηματικά Λυκείου (βαθμωτό έναντι διανυσματικού, πρόσθεση, πολλαπλασιασμός κ.λπ.)

**Τι είναι η γλώσσα Assembly;**

Η γλώσσα Assembly είναι μια γλώσσα προγραμματισμού στην οποία γράφετε κώδικα που αντιστοιχεί άμεσα στις εντολές που επεξεργάζεται μια CPU. Η γλώσσα Assembly που είναι αναγνώσιμη από τον άνθρωπο, όπως υποδηλώνει το όνομά της, *συναρμολογείται* σε δυαδικά δεδομένα, γνωστά ως *κώδικας μηχανής*, τα οποία μπορεί να κατανοήσει η CPU. Μπορεί να δείτε τον κώδικα γλώσσας Assembly να αναφέρεται ως «assembly» ή «asm» για συντομία.

Η συντριπτική πλειοψηφία του κώδικα assembly στο FFmpeg είναι αυτό που είναι γνωστό ως *SIMD, Single Instruction Multiple Data*. Το SIMD αναφέρεται μερικές φορές ως προγραμματισμός διανυσμάτων. Αυτό σημαίνει ότι μια συγκεκριμένη εντολή λειτουργεί σε πολλαπλά στοιχεία δεδομένων ταυτόχρονα. Οι περισσότερες γλώσσες προγραμματισμού λειτουργούν σε ένα στοιχείο δεδομένων κάθε φορά, κάτι που είναι γνωστό ως βαθμωτός προγραμματισμός (scalar programming).

Όπως ίσως μαντέψατε, το SIMD προσφέρεται για την επεξεργασία εικόνων, βίντεο και ήχου, τα οποία έχουν πολλά δεδομένα διατεταγμένα διαδοχικά στη μνήμη. Υπάρχουν εξειδικευμένες εντολές διαθέσιμες στην Κεντρική Μονάδα Επεξεργασίας (CPU) για να μας βοηθήσουν να επεξεργαστούμε διαδοχικά δεδομένα.

Στο FFmpeg, θα δείτε τους όρους «assembly function» (συνάρτηση assembly), «SIMD» και «vector(ise)» (διανυσματοποίηση) να χρησιμοποιούνται εναλλακτικά. Όλοι αναφέρονται στο ίδιο πράγμα: Στη χειροκίνητη συγγραφή μιας συνάρτησης σε γλώσσα assembly για την ταυτόχρονη επεξεργασία πολλαπλών στοιχείων δεδομένων. Ορισμένα έργα (projects) μπορεί επίσης να αναφέρονται σε αυτά ως «assembly kernels» (πυρήνες assembly).

Όλα αυτά μπορεί να ακούγονται περίπλοκα, αλλά είναι σημαντικό να θυμάστε ότι στο FFmpeg, μαθητές λυκείου έχουν γράψει κώδικα assembly. Όπως με τα πάντα, η εκμάθηση είναι 50% ορολογία και 50% πραγματική μάθηση.

**Γιατί γράφουμε σε γλώσσα assembly;**  
Για να κάνουμε την επεξεργασία πολυμέσων γρήγορη. Είναι πολύ συνηθισμένο να επιτυγχάνεται βελτίωση ταχύτητας 10 φορές ή και περισσότερο από τη συγγραφή κώδικα assembly, κάτι που είναι ιδιαίτερα σημαντικό όταν θέλουμε να αναπαράγουμε βίντεο σε πραγματικό χρόνο χωρίς διακοπές (stuttering). Επίσης, εξοικονομεί ενέργεια και παρατείνει τη διάρκεια ζωής της μπαταρίας. Αξίζει να σημειωθεί ότι οι συναρτήσεις κωδικοποίησης και αποκωδικοποίησης βίντεο είναι μερικές από τις πιο χρησιμοποιημένες συναρτήσεις στον κόσμο, τόσο από τελικούς χρήστες όσο και από μεγάλες εταιρείες στα κέντρα δεδομένων (datacenters) τους. Έτσι, ακόμη και μια μικρή βελτίωση αθροίζεται γρήγορα.

Θα δείτε συχνά, στο διαδίκτυο, ανθρώπους να χρησιμοποιούν *intrinsics* (ενδογενείς συναρτήσεις), που είναι συναρτήσεις παρόμοιες με τη C οι οποίες αντιστοιχούν σε εντολές assembly για να επιτρέψουν ταχύτερη ανάπτυξη. Στο FFmpeg δεν χρησιμοποιούμε intrinsics, αλλά αντ' αυτού γράφουμε κώδικα assembly χειροκίνητα. Αυτός είναι ένας τομέας διαφωνίας, αλλά τα intrinsics είναι συνήθως περίπου 10-15% πιο αργά από τον χειρόγραφο κώδικα assembly (οι υποστηρικτές των intrinsics θα διαφωνούσαν), ανάλογα με τον μεταγλωττιστή (compiler). Για το FFmpeg, κάθε κομμάτι επιπλέον απόδοσης βοηθάει, γι' αυτό και γράφουμε απευθείας σε κώδικα assembly. Υπάρχει επίσης το επιχείρημα ότι τα intrinsics είναι δύσκολο να διαβαστούν λόγω της χρήσης της «Ουγγρικής Σημειογραφίας» [Hungarian Notation](https://en.wikipedia.org/wiki/Hungarian_notation).

Μπορεί επίσης να δείτε *ενσωματωμένη assembly* (inline assembly) (δηλαδή χωρίς τη χρήση intrinsics) να παραμένει σε μερικά σημεία στο FFmpeg για ιστορικούς λόγους, ή σε έργα όπως ο πυρήνας του Linux (Linux Kernel) λόγω πολύ συγκεκριμένων περιπτώσεων χρήσης εκεί. Αυτό συμβαίνει όταν ο κώδικας assembly δεν βρίσκεται σε ξεχωριστό αρχείο, αλλά είναι γραμμένος ενσωματωμένα με τον κώδικα C. Η επικρατούσα άποψη σε έργα όπως το FFmpeg είναι ότι αυτός ο κώδικας είναι δύσκολος στην ανάγνωση, δεν υποστηρίζεται ευρέως από τους μεταγλωττιστές (compilers) και δεν είναι συντηρήσιμος (unmaintainable).

Τέλος, θα δείτε πολλούς αυτοαποκαλούμενους ειδικούς στο διαδίκτυο να λένε ότι τίποτα από όλα αυτά δεν είναι απαραίτητο και ότι ο μεταγλωττιστής (compiler) μπορεί να κάνει όλη αυτή τη «διανυσματοποίηση» (vectorisation) για εσάς. Τουλάχιστον για εκπαιδευτικούς σκοπούς, αγνοήστε τους: πρόσφατες δοκιμές για παράδειγμα στο [the dav1d project](https://www.videolan.org/projects/dav1d.html) έδειξαν περίπου 2 φορές επιτάχυνση από αυτήν την αυτόματη διανυσματοποίηση, ενώ οι χειρόγραφες εκδόσεις μπορούσαν να φτάσουν τις 8 φορές.

**Εκδοχές (Flavours) της γλώσσας Assembly**  
Αυτά τα μαθήματα θα επικεντρωθούν στη γλώσσα assembly x86 64-bit. Αυτή είναι επίσης γνωστή ως amd64, αν και εξακολουθεί να λειτουργεί σε επεξεργαστές (CPU) της Intel. Υπάρχουν και άλλοι τύποι assembly για άλλους επεξεργαστές όπως οι ARM και RISC-V και πιθανώς στο μέλλον αυτά τα μαθήματα θα επεκταθούν για να τους καλύψουν.
Υπάρχουν δύο εκδοχές σύνταξης της x86 assembly που θα δείτε στο διαδίκτυο: η AT&T και η Intel. Η σύνταξη AT&T είναι παλαιότερη και πιο δύσκολη στην ανάγνωση σε σύγκριση με τη σύνταξη της Intel. Επομένως, θα χρησιμοποιήσουμε τη σύνταξη της Intel.

**Υποστηρικτικό υλικό**  
Μπορεί να σας εκπλήξει το γεγονός ότι βιβλία ή διαδικτυακοί πόροι όπως το Stack Overflow δεν είναι ιδιαίτερα χρήσιμα ως αναφορές. Αυτό οφείλεται εν μέρει στην επιλογή μας να χρησιμοποιούμε χειρόγραφη assembly με σύνταξη Intel. Αλλά και επειδή πολλοί διαδικτυακοί πόροι επικεντρώνονται στον προγραμματισμό λειτουργικών συστημάτων ή στον προγραμματισμό υλικού (hardware), χρησιμοποιώντας συνήθως κώδικα που δεν είναι SIMD. Η assembly του FFmpeg είναι ιδιαίτερα εστιασμένη στην επεξεργασία εικόνας υψηλής απόδοσης, και όπως θα δείτε, αποτελεί μια ιδιαίτερα μοναδική προσέγγιση στον προγραμματισμό assembly. Παρόλα αυτά, είναι εύκολο να κατανοήσετε άλλες περιπτώσεις χρήσης της assembly μόλις ολοκληρώσετε αυτά τα μαθήματα.

Πολλά βιβλία εμβαθύνουν σε πολλές λεπτομέρειες της αρχιτεκτονικής των υπολογιστών πριν διδάξουν assembly. Αυτό είναι καλό αν αυτό είναι που θέλετε να μάθετε, αλλά από τη δική μας σκοπιά, είναι σαν να μελετάτε τις μηχανές πριν μάθετε να οδηγείτε αυτοκίνητο.

Παρόλα αυτά, τα διαγράμματα στα μεταγενέστερα μέρη του βιβλίου «The Art of 64-bit assembly» που δείχνουν τις εντολές SIMD και τη συμπεριφορά τους σε οπτική μορφή είναι χρήσιμα: [https://artofasm.randallhyde.com/](https://artofasm.randallhyde.com/)

Ένας διακομιστής Discord (server) είναι διαθέσιμος για να απαντήσει σε ερωτήσεις: [https://discord.com/invite/Ks5MhUhqfB](https://discord.com/invite/Ks5MhUhqfB)

**Καταχωρητές (Registers)**  
Οι καταχωρητές είναι περιοχές στην ΚΜΕ (CPU) όπου τα δεδομένα μπορούν να υποστούν επεξεργασία. Οι ΚΜΕ δεν λειτουργούν απευθείας πάνω στη μνήμη, αλλά αντ' αυτού τα δεδομένα φορτώνονται στους καταχωρητές, επεξεργάζονται και εγγράφονται πίσω στη μνήμη. Στη γλώσσα assembly, γενικά, δεν μπορείτε να αντιγράψετε απευθείας δεδομένα από μια θέση μνήμης σε μια άλλη χωρίς πρώτα να περάσετε αυτά τα δεδομένα μέσω ενός καταχωρητή.

**Καταχωρητές Γενικού Σκοπού (General Purpose Registers)**  
Ο πρώτος τύπος καταχωρητή είναι αυτός που είναι γνωστός ως Καταχωρητής Γενικού Σκοπού (GPR). Οι GPRs αναφέρονται ως γενικού σκοπού επειδή μπορούν να περιέχουν είτε δεδομένα, στην περίπτωση αυτή μια τιμή έως 64-bit, είτε μια διεύθυνση μνήμης (έναν δείκτη). Μια τιμή σε έναν GPR μπορεί να επεξεργαστεί μέσω πράξεων όπως πρόσθεση, πολλαπλασιασμός, μετατόπιση κ.λπ.

Στα περισσότερα βιβλία για assembly, υπάρχουν ολόκληρα κεφάλαια αφιερωμένα στις λεπτές αποχρώσεις των GPRs, το ιστορικό τους υπόβαθρο κ.λπ. Αυτό συμβαίνει επειδή οι GPRs είναι σημαντικοί όσον αφορά τον προγραμματισμό λειτουργικών συστημάτων, την αντίστροφη μηχανική (reverse engineering), κ.λπ. Στον κώδικα assembly που γράφεται στο FFmpeg, οι GPRs μοιάζουν περισσότερο με σκαλωσιές (scaffolding) και τις περισσότερες φορές οι πολυπλοκότητές τους δεν χρειάζονται και αφαιρούνται (abstracted away).

**Διανυσματικοί καταχωρητές (Vector registers)**  
Οι διανυσματικοί (SIMD) καταχωρητές, όπως υποδηλώνει το όνομά τους, περιέχουν πολλαπλά στοιχεία δεδομένων. Υπάρχουν διάφοροι τύποι διανυσματικών καταχωρητών:

* καταχωρητές mm - καταχωρητές MMX, μεγέθους 64-bit, ιστορικοί και δεν χρησιμοποιούνται πλέον πολύ
* καταχωρητές xmm - καταχωρητές XMM, μεγέθους 128-bit, ευρέως διαθέσιμοι
* καταχωρητές ymm - καταχωρητές YMM, μεγέθους 256-bit, με μερικές περιπλοκές κατά τη χρήση τους
* καταχωρητές zmm - καταχωρητές ZMM, μεγέθους 512-bit, περιορισμένης διαθεσιμότητας

Οι περισσότεροι υπολογισμοί στη συμπίεση και αποσυμπίεση βίντεο βασίζονται σε ακέραιους αριθμούς, οπότε θα παραμείνουμε σε αυτό. Ακολουθεί ένα παράδειγμα 16 byte σε έναν καταχωρητή xmm:

| a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

Αλλά θα μπορούσε να είναι οκτώ λέξεις (words) (ακέραιοι 16-bit)

| a | b | c | d | e | f | g | h |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

Ή τέσσερις διπλές λέξεις (double words) (ακέραιοι 32-bit)

| a | b | c | d |
| :---- | :---- | :---- | :---- |

Ή δύο τετραπλές λέξεις (quadwords) (ακέραιοι 64-bit):

| a | b |
| :---- | :---- |

Για να ανακεφαλαιώσουμε:

*   **b**ytes (μπάιτ) - δεδομένα 8-bit
*   **w**ords (λέξεις) - δεδομένα 16-bit
*   **d**oublewords (διπλές λέξεις) - δεδομένα 32-bit
*   **q**uadwords (τετραπλές λέξεις) - δεδομένα 64-bit
*   **d**ouble **q**uadwords (διπλές τετραπλές λέξεις) - δεδομένα 128-bit

Οι έντονοι χαρακτήρες θα είναι σημαντικοί αργότερα.

**Συμπερίληψη του x86inc.asm**  
Θα δείτε σε πολλά παραδείγματα ότι συμπεριλαμβάνουμε το αρχείο x86inc.asm. Το X86inc.asm είναι ένα ελαφρύ επίπεδο αφαίρεσης (lightweight abstraction layer) που χρησιμοποιείται στα FFmpeg, x264 και dav1d για να κάνει τη ζωή ενός προγραμματιστή assembly ευκολότερη. Βοηθά με πολλούς τρόπους, αλλά για αρχή, ένα από τα χρήσιμα πράγματα που κάνει είναι ότι ονομάζει τους GPRs, r0, r1, r2. Αυτό σημαίνει ότι δεν χρειάζεται να θυμάστε κανένα όνομα καταχωρητή. Όπως αναφέρθηκε προηγουμένως, οι GPRs είναι γενικά απλώς σκαλωσιές (scaffolding), οπότε αυτό κάνει τη ζωή πολύ πιο εύκολη.

**Ένα απλό απόσπασμα κώδικα βαθμωτής assembly** 

Ας δούμε ένα απλό (και πολύ τεχνητό) απόσπασμα κώδικα βαθμωτής assembly (κώδικας assembly που λειτουργεί σε μεμονωμένα στοιχεία δεδομένων, ένα κάθε φορά, μέσα σε κάθε εντολή) για να δούμε τι συμβαίνει:

```assembly
mov  r0q, 3  
inc  r0q  
dec  r0q  
imul r0q, 5
```

Στην πρώτη γραμμή, η *άμεση τιμή* (immediate value) 3 (μια τιμή που αποθηκεύεται απευθείας στον ίδιο τον κώδικα assembly σε αντίθεση με μια τιμή που ανακτάται από τη μνήμη) αποθηκεύεται στον καταχωρητή r0 ως τετραπλή λέξη (quadword). Σημειώστε ότι στη σύνταξη της Intel, ο τελεστέος προέλευσης (source operand) (η τιμή ή η θέση που παρέχει τα δεδομένα, που βρίσκεται στα δεξιά) μεταφέρεται στον τελεστέο προορισμού (destination operand) (η θέση που λαμβάνει τα δεδομένα, που βρίσκεται στα αριστερά), παρόμοια με τη συμπεριφορά της memcpy. Μπορείτε επίσης να το διαβάσετε ως «r0q = 3», αφού η σειρά είναι η ίδια. Το επίθημα «q» του r0 υποδηλώνει ότι ο καταχωρητής χρησιμοποιείται ως τετραπλή λέξη. Η εντολή inc αυξάνει την τιμή ώστε το r0q να περιέχει 4, η dec μειώνει την τιμή ξανά στο 3. Η imul πολλαπλασιάζει την τιμή με το 5. Έτσι, στο τέλος, το r0q περιέχει 15.

Σημειώστε ότι οι αναγνώσιμες από τον άνθρωπο εντολές όπως mov και inc, οι οποίες μετατρέπονται σε κώδικα μηχανής από τον assembler, είναι γνωστές ως μνημονικά (mnemonics). Μπορεί να δείτε στο διαδίκτυο και σε βιβλία τα μνημονικά να αναπαρίστανται με κεφαλαία γράμματα όπως MOV και INC, αλλά είναι τα ίδια με τις πεζές εκδόσεις. Στο FFmpeg, χρησιμοποιούμε πεζά μνημονικά και κρατάμε τα κεφαλαία για τις μακροεντολές (macros).

**Κατανόηση μιας βασικής διανυσματικής συνάρτησης** 

Αυτή είναι η πρώτη μας συνάρτηση SIMD:

```assembly
%include "x86inc.asm"

SECTION .text

;static void add_values(uint8_t *src, const uint8_t *src2)  
INIT_XMM sse2  
cglobal add_values, 2, 2, 2, src, src2   
    movu  m0, [srcq]  
    movu  m1, [src2q]

    paddb m0, m1

    movu  [srcq], m0

    RET
```

Ας το δούμε γραμμή προς γραμμή:

```assembly
%include "x86inc.asm"
```

Αυτή είναι μια «επικεφαλίδα» (header) που αναπτύχθηκε στις κοινότητες των x264, FFmpeg και dav1d για να παρέχει βοηθητικές ρουτίνες (helpers), προκαθορισμένα ονόματα και μακροεντολές (macros) (όπως η cglobal παρακάτω) για την απλοποίηση της συγγραφής κώδικα assembly.

```assembly
SECTION .text
```

Αυτό υποδηλώνει το τμήμα όπου τοποθετείται ο κώδικας που θέλετε να εκτελεστεί. Αυτό έρχεται σε αντίθεση με το τμήμα .data, όπου μπορείτε να τοποθετήσετε σταθερά δεδομένα.

```assembly
;static void add_values(uint8_t *src, const uint8_t *src2)  
INIT_XMM sse2
```

Η πρώτη γραμμή είναι ένα σχόλιο (το ερωτηματικό «;» στην asm είναι σαν το «//» στη C) που δείχνει πώς φαίνεται το όρισμα της συνάρτησης στη C. Η δεύτερη γραμμή δείχνει πώς αρχικοποιούμε τη συνάρτηση για να χρησιμοποιήσει καταχωρητές XMM, χρησιμοποιώντας το σύνολο εντολών sse2. Αυτό συμβαίνει επειδή η paddb είναι μια εντολή sse2. Θα καλύψουμε το sse2 με περισσότερες λεπτομέρειες στο επόμενο μάθημα.

```assembly
cglobal add_values, 2, 2, 2, src, src2
```

Αυτή είναι μια σημαντική γραμμή καθώς ορίζει μια συνάρτηση C με το όνομα «add_values».

Ας εξετάσουμε κάθε στοιχείο ένα προς ένα:

* Η επόμενη παράμετρος δείχνει ότι έχει δύο ορίσματα συνάρτησης.
* Η παράμετρος μετά από αυτή δείχνει ότι θα χρησιμοποιήσουμε δύο GPRs για τα ορίσματα. Σε ορισμένες περιπτώσεις μπορεί να θέλουμε να χρησιμοποιήσουμε περισσότερους GPRs, οπότε πρέπει να πούμε στο x86util ότι χρειαζόμαστε περισσότερους.
* Η παράμετρος μετά από αυτή λέει στο x86util πόσους καταχωρητές XMM θα χρησιμοποιήσουμε.
* Οι επόμενες δύο παράμετροι είναι ετικέτες για τα ορίσματα της συνάρτησης.

Αξίζει να σημειωθεί ότι παλαιότερος κώδικας μπορεί να μην έχει ετικέτες για τα ορίσματα της συνάρτησης, αλλά αντ' αυτού να απευθύνεται απευθείας στους GPRs χρησιμοποιώντας r0, r1 κ.λπ.

```assembly
    movu  m0, [srcq]  
    movu  m1, [src2q]
```

Η movu είναι συντομογραφία για την movdqu (move double quad unaligned - μετακίνηση μη ευθυγραμμισμένης διπλής τετραπλής λέξης). Η ευθυγράμμιση (Alignment) θα καλυφθεί σε άλλο μάθημα, αλλά προς το παρόν η movu μπορεί να θεωρηθεί ως μια μετακίνηση 128-bit από το [srcq]. Στην περίπτωση της mov, οι αγκύλες σημαίνουν ότι η διεύθυνση στο [srcq] αποαναφέρεται (dereferenced), το ισοδύναμο του **src στη C*. Αυτό είναι γνωστό ως φόρτωση (load). Σημειώστε ότι το επίθημα «q» αναφέρεται στο μέγεθος του δείκτη *(*δηλαδή στη C αντιπροσωπεύει το *sizeof(*src) == 8 σε συστήματα 64-bit, και η x86asm είναι αρκετά έξυπνη ώστε να χρησιμοποιεί 32-bit σε συστήματα 32-bit) αλλά η υποκείμενη φόρτωση είναι 128-bit.

Σημειώστε ότι δεν αναφερόμαστε στους διανυσματικούς καταχωρητές με το πλήρες όνομά τους, σε αυτήν την περίπτωση xmm0, αλλά ως m0, μια αφηρημένη μορφή (abstracted form). Σε μελλοντικά μαθήματα θα δείτε πώς αυτό σημαίνει ότι μπορείτε να γράψετε κώδικα μία φορά και να λειτουργεί σε πολλαπλά μεγέθη καταχωρητών SIMD.

```assembly
paddb m0, m1
```

Η paddb (διαβάστε το στο μυαλό σας ως *p-add-b*) προσθέτει κάθε byte σε κάθε καταχωρητή όπως φαίνεται παρακάτω. Το πρόθεμα «p» σημαίνει «packed» (συσκευασμένο) και χρησιμοποιείται για την αναγνώριση των διανυσματικών εντολών έναντι των βαθμωτών εντολών. Το επίθημα «b» δείχνει ότι πρόκειται για πρόσθεση ανά byte (πρόσθεση των bytes).

| a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

\+

| q | r | s | t | u | v | w | x | y | z | aa | ab | ac | ad | ae | af |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

\=

| a+q | b+r | c+s | d+t | e+u | f+v | g+w | h+x | i+y | j+z | k+aa | l+ab | m+ac | n+ad | o+ae | p+af |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

```assembly
movu  [srcq], m0
```

Αυτό είναι γνωστό ως αποθήκευση (store). Τα δεδομένα εγγράφονται πίσω στη διεύθυνση του δείκτη srcq.

```assembly
RET
```

Αυτή είναι μια μακροεντολή (macro) για να δηλώσει την επιστροφή της συνάρτησης. Σχεδόν όλες οι συναρτήσεις assembly στο FFmpeg τροποποιούν τα δεδομένα στα ορίσματα αντί να επιστρέφουν μια τιμή.

Όπως θα δείτε στην εργασία, δημιουργούμε δείκτες συνάρτησης (function pointers) σε συναρτήσεις assembly και τους χρησιμοποιούμε όπου είναι διαθέσιμοι.

[Επόμενο Μάθημα](../lesson_02/index.el.md)