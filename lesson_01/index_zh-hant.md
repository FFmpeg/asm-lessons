**FFmpeg 組合語言第一課**

**介紹**

歡迎來到FFmpeg組合語言學校。你已經朝著程式設計中最有趣、最具挑戰性和最有回報的旅程邁出了第一步。這些課程將為你奠定FFmpeg中組合語言的編寫基礎，並讓你了解電腦中實際發生的情況。

**所需知識**

* C語言知識，特別是指標。如果你不了解C語言，建議學習[《C程式設計語言》](https://zh.wikipedia.org/wiki/C程序设计语言_(书))一書
* 高中數學（純量與向量、加法、乘法等）

**什麼是組合語言 (Assembly language)？**

組合語言 (Assembly language) 是一種程式設計語言，你編寫的程式碼直接對應於CPU處理的指令。人類可讀的組合語言，顧名思義，被*組譯 (assembled)* 成CPU能夠理解的二進位資料，稱為*機器碼 (machine code)*。你可能會看到組合語言程式碼被簡稱為「assembly」或「asm」。

FFmpeg中的絕大多數組合程式碼都是所謂的*SIMD，單指令多資料 (Single Instruction Multiple Data)*。SIMD有時也被稱為向量程式設計 (vector programming)。這意味著特定指令能同時對多個資料元素進行操作。大多數程式設計語言一次只處理一個資料元素，稱為純量程式設計 (scalar programming)。

你可能已經猜到，SIMD非常適合處理影像、視訊和音訊，因為這些資料在記憶體中按順序排列。CPU中有專門的指令幫助我們處理順序資料。

在FFmpeg中，你會看到「組合函式 (assembly function)」、「SIMD」和「向量（化）」這些術語被互換使用。它們都指的是同一件事：通過手寫組合語言函式一次性地處理多個資料元素。一些專案也可能將這些稱為「組合核心 (assembly kernels)」。

所有這些聽起來可能比較複雜，但謹記，在FFmpeg專案中，高中生也編寫了組合程式碼。與所有事物一樣，學習是50%術語和50%實際學習。

**為什麼我們用組合語言編寫？**  

為了使多媒體處理得更快。編寫組合程式碼通常能帶來10倍或以上的速度提升，這對於即時播放視訊而不卡頓尤為重要。它還能節省能源並延長電池壽命。值得注意的是，視訊編碼和解碼是全球最常用的功能之一，無論是普通使用者還是大型企業的資料中心都用到它們。因此，即使是微小的改進，也能迅速積累出顯著的效果。

在網路上，你會經常看到人們使用*內聯函式 (intrinsics)*，這些C語言風格的函式映射到組合指令，以便更快地開發。在 FFmpeg 中，我們不使用內聯函式，而是手寫組合程式碼。這是一個有爭議的部分，但內聯函式通常比手寫組合慢約10-15%（內聯函式支持者可能會不同意），這取決於編譯器。對於 FFmpeg 來說，每一點額外的效能提升都有用，這就是為什麼我們直接使用組合程式碼。還有一種觀點認為，內聯函式由於使用了「[匈牙利命名法](https://zh.wikipedia.org/wiki/匈牙利命名法)」而難以閱讀。

出於歷史原因，你可能還會在 FFmpeg 的一些地方看到*內聯組合 (inline assembly)*（即不使用內聯函式），或者在 Linux 核心等專案中因為非常特殊的應用場景而看到內聯組合。這是指組合程式碼不寫在單獨的檔案中，在像 FFmpeg 這樣的專案中，主流觀點認為這種程式碼難以閱讀，缺乏廣泛的編譯器支援，並且難以維護。

最後，你會看到很多自稱專家的人在網路上說這些都是沒必要的，編譯器可以為你完成所有這些「向量化」工作。至少以學習的目的，請忽視他們：例如，[dav1d專案](https://www.videolan.org/projects/dav1d.html)的最近測試顯示，這種自動向量化帶來了約2倍的速度提升，而手寫版本可以達到8倍。

**組合語言的風格**  

本課程將專注於 x86 64 位組合語言，它也被稱為 amd64，儘管它同樣適用於 Intel 處理器。此外，不同的 CPU 也有其他類型的組合語言，例如 ARM 和 RISC-V，未來這些課程可能會擴展到涵蓋這些架構。

網路上常見的 x86 組合風格有兩種：AT&T 和 Intel。AT&T 語法較早，但相較於 Intel 語法更難閱讀。因此，我們將使用 Intel 風格。

**輔助材料**  
你可能會驚訝地發現，書籍或線上資源（如 Stack Overflow）作為參考並不是特別有用。部分原因是我們選擇手寫 Intel 組合。但也因為很多線上資源都集中在作業系統程式設計或硬體程式設計上，通常使用非 SIMD 程式碼。而 FFmpeg 的組合特別側重於高效能圖像處理，正如你將看到的，它採用了一種獨特的組合程式設計方法。不過，一旦你完成這些課程，理解其他組合應用場景就很容易了。

許多書籍在教組合之前會深入介紹電腦架構細節。如果你想學這些，那很好，但從我們的角度來看，這就像在學習開車之前研究引擎。

話雖如此，《64位元組合語言的程式設計藝術》 (The Art of 64-bit assembly) 一書後半部分的圖解，以可視化方式展示 SIMD 指令及其行為，還是很有用的：[https://artofasm.randallhyde.com/](https://artofasm.randallhyde.com/)

我們有個 Discord 伺服器用來解答問題:  
[https://discord.com/invite/Ks5MhUhqfB](https://discord.com/invite/Ks5MhUhqfB)

**暫存器 (Register)**  
暫存器是 CPU 內用於處理資料的區域。CPU 並不會直接對記憶體進行操作，而是先將資料載入到暫存器中進行處理，然後再寫回記憶體。在組合語言中，通常不能直接在兩個記憶體位置之間複製資料，而必須先通過暫存器中轉。

**通用暫存器 (General Purpose Register)**  
第一種暫存器被稱為通用暫存器（GPR）。之所以稱為「通用」，是因為它們既可以儲存資料（最大支援 64 位元值），也可以儲存記憶體位址（指標）。GPR 中的值可以進行各種操作，如加法、乘法、位移等。

在大多數組合書籍中，會有整章內容專門講解 GPR 的細節和歷史背景等。這是因為在作業系統程式設計、逆向工程等領域，GPR 是非常重要的。然而，在 FFmpeg 中編寫的組合程式碼裡，GPR 更像是鷹架，大多數情況下不需要它們的複雜性，並且被抽象出來。

**向量暫存器 (Vector registers)**  
向量 (SIMD) 暫存器，顧名思義，包含多個資料元素。不同類型的向量暫存器包括：

* mm暫存器 - MMX暫存器，64位元大小，歷史悠久，目前已不常使用 
* xmm暫存器 - XMM暫存器，128位元大小，廣泛可用  
* ymm暫存器 - YMM暫存器，256位元大小，使用時有一些複雜性   
* zmm暫存器 - ZMM暫存器，512位元大小，可用性有限

視訊壓縮和解壓縮中的大多數計算是基於整數的，因此我們將繼續使用整數類型。以下是 xmm 暫存器中 16 位元組 (bytes) 資料的一個例子：

| a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

但它也可以是八個字 (words)（16位元 (bit) 整數）

| a | b | c | d | e | f | g | h |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

或四個雙字 (double words)（32位元整數）

| a | b | c | d |
| :---- | :---- | :---- | :---- |

或兩個四字 (quadwords)（64位元整數）：

| a | b |
| :---- | :---- |

回顧一下：


* **b**ytes 位元組 - 8位元資料  
* **w**ords 字 - 16位元資料  
* **d**oublewords 雙字 - 32位元資料  
* **q**uadwords 四字 - 64位元資料  
* **d**ouble **q**uadwords 雙四字 - 128位元資料

加粗的字元稍後會很重要。

**x86inc.asm 包含檔案**  
在許多範例中，你會看到我們包含了檔案 x86inc.asm。x86inc.asm 是 FFmpeg、x264 和 dav1d 中使用的輕量級抽象層，旨在簡化組合程式設計師的工作。它在許多方面提供幫助，但首先，它的一個有用功能是給 GPR 暫存器標記為 r0、r1、r2。這樣，你就不必記住任何暫存器的名稱。如前所述，GPR 通常只是鷹架，所以這種做法大大簡化了程式設計過程。

**一個簡單的純量組合 (scalar asm) 片段**

讓我們看一段簡單（且非常人工構造）的純量組合程式碼（每條指令一次只對單個資料項進行操作的組合程式碼），看看發生了什麼：

```assembly
mov  r0q, 3  
inc  r0q  
dec  r0q  
imul r0q, 5
```

在第一行中，*立即值 (immediate value)* 3（直接儲存在組合程式碼中的值，而不是從記憶體中獲取的值）被儲存到暫存器 r0 中，作為一個四字（quadword）值。注意，在 Intel 風格中，來源運算元（提供資料的值或位置，位於右側）被傳送到目標運算元（接收資料的位置，位於左側），類似於 memcpy 的行為。你也可以理解為「r0q = 3」，因為順序是相同的。r0 的 「q」 後綴表示該暫存器作為四字 (**q**uadword) 來用。「inc」 操作將值增加，使 r0q 包含 4，「dec」 操作將值減少回 3，「imul」 將值乘以 5。因此，最終 r0q 包含 15。

請注意，組譯器 (assembler) 將人類可讀的指令（如 mov 和 inc）組譯成機器碼，這些被稱為*助記符 (mnemonics)*。你可能會在網路上和書籍中看到助記符以大寫字母表示，如 MOV 和 INC，但它們與小寫版本完全相同。在 FFmpeg 中，我們使用小寫助記符，並將大寫保留給巨集 (macro) 定義。

**理解基本的向量函式 (vector function)**

以下是我們的第一個 SIMD 函式：

```assembly
%include "x86inc.asm"

SECTION .text

;static void add_values(uint8_t *src, const uint8_t *src2)  
INIT_XMM sse2  
cglobal add_values, 2, 2, 2, src, src2   
    movu  m0, [srcq]  
    movu  m1, [src2q]

    paddb m0, m1

    movu  [srcq], m0

    RET
```

讓我們逐行分析：

```assembly
%include "x86inc.asm"
```

這是一個由x264、FFmpeg 和 dav1d 社群開發的「標頭檔」，提供幫助函式、預定義名稱和巨集（如下面的cglobal）以簡化組合編寫。

```assembly
SECTION .text
```

這表示程式碼執行所在的區域。這與 .data 部分相對，你可以在 .data 部分放置常數資料。

```assembly
;static void add_values(uint8_t *src, const uint8_t *src2)  
INIT_XMM sse2
```

第一行是註解（在組合中，分號 「;」 的作用類似於 C 語言中的 「//」），用於展示該函式的 C 語言參數形式。第二行用於初始化函式，使其能夠使用 XMM 暫存器，並指定使用 sse2 指令集。這是因為 paddb 是一個 sse2 指令。我們將在下一課中更詳細地介紹 sse2。

```assembly
cglobal add_values, 2, 2, 2, src, src2
```

這一行至關重要，它定義了一個名為 add_values 的 C 語言函式。

讓我們逐項解析：

* 下一個參數指定了該函式有兩個參數。
* 再下一個參數指定這兩個參數將使用兩個 GPR 進行傳遞。在某些情況下，我們可能需要更多的 GPR，因此必須告訴 x86util 我們需要額外的暫存器。
* 再下一個參數指定了 x86util 需要多少個 XMM 暫存器。
* 最後兩個參數是函式參數的標籤。

值得注意的是，舊程式碼可能不會為函式參數添加標籤，而是直接使用 r0、r1 等通用暫存器（GPR）來存取參數。

```assembly
    movu  m0, [srcq]  
    movu  m1, [src2q]
```

movu 是 movdqu（move double quad unaligned 移動雙四字未對齊）的簡寫。關於對齊的內容我們會在後續課程中講解，但目前可以將 movu 視為從 [srcq] 進行 128 位元資料傳輸。對於 mov 指令，方括號表示對 [srcq] 指向的位址進行解參照，相當於 *C 語言中的 \*src*，這就是所謂的「載入」（load）。需要注意的是，q 後綴表示指標的大小（即在 C 語言中在 64 位元系統上 sizeof(*src) == 8，x86 組合在 32 位元系統上則會自動調整為 32 位元），但實際載入的資料仍然是 128 位元的。

需要注意的是，我們並不使用向量暫存器的完整名稱（例如 xmm0），而是使用抽象形式的 m0。在後續課程中，你會看到這種方式的優勢 —— 它允許你編寫一次程式碼，並在不同大小的 SIMD 暫存器上通用適用。

```assembly
paddb m0, m1
```
 
paddb（可以在腦海中讀作 *p-add-b*）會對每個暫存器中的每個位元組進行相加，如下所示。「p」 前綴代表 「packed」（打包），用於區分向量指令和純量指令。「b」 後綴表示這是 按位元組（bytewise） 進行的加法運算。

| a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

\+

| q | r | s | t | u | v | w | x | y | z | aa | ab | ac | ad | ae | af |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

\=

| a+q | b+r | c+s | d+t | e+u | f+v | g+w | h+x | i+y | j+z | k+aa | l+ab | m+ac | n+ad | o+ae | p+af |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

```assembly
movu  [srcq], m0
```

這就是所謂的儲存。資料被寫回 srcq 指標中的位址。

```assembly
RET
```

這是一個表示函式返回的巨集 (macro)。在 FFmpeg 中，幾乎所有組合函式都會直接修改參數中的資料，而不是返回一個值。

在後續的作業中，你會看到，我們會為組合函式創建函式指標，並在可用的地方使用它們。

[下一課](../lesson_02/index_zh-hant.md)
