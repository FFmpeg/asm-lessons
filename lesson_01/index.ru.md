**Урок первый по языку ассемблера FFmpeg**

**Введение**

Добро пожаловать в Школу языка ассемблера FFmpeg. Вы сделали первый шаг на самом интересном, сложном и полезном пути в программировании. Эти уроки дадут вам основу в том, как язык ассемблера используется в FFmpeg, и откроют ваши глаза на то, что на самом деле происходит в вашем компьютере.

**Требуемые знания**

* Знание языка C, в частности указателей. Если вы не знаете C, проработайте книгу [Язык программирования C](https://en.wikipedia.org/wiki/The_C_Programming_Language)  
* Школьная математика (скаляр против вектора, сложение, умножение и т.д.)

**Что такое язык ассемблера?**

Язык ассемблера — это язык программирования, на котором вы пишете код, напрямую соответствующий инструкциям, которые обрабатывает процессор. Человекочитаемый язык ассемблера, как следует из названия, *ассемблируется* в двоичные данные, известные как *машинный код*, который может понять процессор. Вы можете видеть, что код на языке ассемблера называют просто "assembly" или "asm".

Подавляющее большинство кода на ассемблере в FFmpeg — это то, что известно как *SIMD, Single Instruction Multiple Data (Одна инструкция — множество данных)*. SIMD иногда называют векторным программированием. Это означает, что конкретная инструкция работает с несколькими элементами данных одновременно. Большинство языков программирования работают с одним элементом данных за раз, что известно как скалярное программирование.

Как вы могли догадаться, SIMD хорошо подходит для обработки изображений, видео и аудио, которые имеют много данных, упорядоченных последовательно в памяти. В процессоре есть специальные инструкции, доступные для помощи нам в обработке последовательных данных.

В FFmpeg вы увидите термины "функция на ассемблере", "SIMD" и "вектор(изация)", используемые взаимозаменяемо. Все они относятся к одному и тому же: написание функции на языке ассемблера вручную для обработки нескольких элементов данных за один раз. Некоторые проекты могут также называть их "ядрами на ассемблере".

Все это может звучать сложно, но важно помнить, что в FFmpeg старшеклассники писали код на ассемблере. Как и во всем, обучение — это 50% жаргона и 50% реального обучения.

**Почему мы пишем на языке ассемблера?**  
Чтобы сделать обработку мультимедиа быстрой. Очень часто можно получить улучшение скорости в 10 раз или более от написания кода на ассемблере, что особенно важно, когда нужно воспроизводить видео в реальном времени без заикания. Это также экономит энергию и продлевает время работы батареи. Стоит отметить, что функции кодирования и декодирования видео — одни из наиболее часто используемых функций на земле, как конечными пользователями, так и крупными компаниями в их центрах обработки данных. Поэтому даже небольшое улучшение быстро суммируется.

Вы часто увидите в Интернете людей, использующих *интринсики*, которые являются C-подобными функциями, которые отображаются на инструкции ассемблера для более быстрой разработки. В FFmpeg мы не используем интринсики, а вместо этого пишем код на ассемблере вручную. Это область противоречий, но интринсики обычно на 10-15% медленнее, чем написанный вручную ассемблер (сторонники интринсиков не согласятся), в зависимости от компилятора. Для FFmpeg каждая крупица дополнительной производительности помогает, поэтому мы пишем непосредственно на коде ассемблера. Есть также аргумент, что интринсики трудно читать из-за их использования "[венгерской нотации](https://en.wikipedia.org/wiki/Hungarian_notation)".

Вы также можете увидеть *встроенный ассемблер* (т.е. не использующий интринсики), остающийся в нескольких местах в FFmpeg по историческим причинам, или в таких проектах, как ядро Linux из-за очень специфических случаев использования там. Это когда код на ассемблере находится не в отдельном файле, а написан в строке с кодом C. Преобладающее мнение в таких проектах, как FFmpeg, заключается в том, что этот код трудно читать, он не широко поддерживается компиляторами и не поддается обслуживанию.

Наконец, вы увидите много самопровозглашенных экспертов в Интернете, говорящих, что все это не нужно, и компилятор может сделать всю эту "векторизацию" за вас. По крайней мере для целей обучения игнорируйте их: недавние тесты, например, в [проекте dav1d](https://www.videolan.org/projects/dav1d.html), показали около 2-кратного ускорения от этой автоматической векторизации, в то время как написанные вручную версии могли достичь 8-кратного ускорения.

**Варианты языка ассемблера**  
Эти уроки будут сосредоточены на 64-битном языке ассемблера x86. Он также известен как amd64, хотя он все еще работает на процессорах Intel. Есть другие типы ассемблера для других процессоров, таких как ARM и RISC-V, и потенциально в будущем эти уроки будут расширены, чтобы охватить их.

Есть два варианта синтаксиса ассемблера x86, которые вы увидите в Интернете: AT&T и Intel. Синтаксис AT&T старше и труднее читается по сравнению с синтаксисом Intel. Поэтому мы будем использовать синтаксис Intel.

**Вспомогательные материалы**  
Вы можете быть удивлены, узнав, что книги или онлайн-ресурсы, такие как Stack Overflow, не особенно полезны в качестве справочников. Это отчасти из-за нашего выбора использовать написанный вручную ассемблер с синтаксисом Intel. Но также потому, что многие онлайн-ресурсы сосредоточены на программировании операционных систем или программировании оборудования, обычно используя не-SIMD код. Ассемблер FFmpeg особенно сосредоточен на высокопроизводительной обработке изображений, и, как вы увидите, это особенно уникальный подход к программированию на ассемблере. Тем не менее, легко понять другие случаи использования ассемблера после завершения этих уроков.

Многие книги вдаются в множество деталей архитектуры компьютера перед обучением ассемблеру. Это нормально, если вы хотите это изучить, но с нашей точки зрения, это все равно что изучать двигатели перед тем, как научиться водить машину.

Тем не менее, диаграммы в поздних частях книги "The Art of 64-bit assembly", показывающие инструкции SIMD и их поведение в визуальной форме, полезны: [https://artofasm.randallhyde.com/](https://artofasm.randallhyde.com/)

Доступен сервер Discord для ответов на вопросы:  
[https://discord.com/invite/Ks5MhUhqfB](https://discord.com/invite/Ks5MhUhqfB)

**Регистры**  
Регистры — это области в процессоре, где могут обрабатываться данные. Процессоры не работают с памятью напрямую, а вместо этого данные загружаются в регистры, обрабатываются и записываются обратно в память. В языке ассемблера, как правило, вы не можете напрямую копировать данные из одного места памяти в другое без предварительной передачи этих данных через регистр.

**Регистры общего назначения**  
Первый тип регистра — это то, что известно как регистр общего назначения (GPR). GPR называются регистрами общего назначения, потому что они могут содержать либо данные, в данном случае до 64-битного значения, либо адрес памяти (указатель). Значение в GPR может быть обработано через операции, такие как сложение, умножение, сдвиг и т.д.

В большинстве книг по ассемблеру целые главы посвящены тонкостям GPR, историческому фону и т.д. Это потому, что GPR важны, когда дело доходит до программирования операционных систем, обратной разработки и т.д. В коде на ассемблере, написанном в FFmpeg, GPR больше похожи на строительные леса, и большую часть времени их сложности не нужны и абстрагированы.

**Векторные регистры**  
Векторные (SIMD) регистры, как следует из названия, содержат несколько элементов данных. Существуют различные типы векторных регистров:

* mm регистры - регистры MMX, размером 64 бита, исторические и больше не используются  
* xmm регистры - регистры XMM, размером 128 бит, широко доступны  
* ymm регистры - регистры YMM, размером 256 бит, некоторые сложности при их использовании   
* zmm регистры - регистры ZMM, размером 512 бит, ограниченная доступность

Большинство вычислений в сжатии и распаковке видео основаны на целых числах, поэтому мы остановимся на этом. Вот пример 16 байт в регистре xmm:

| a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

Но это могут быть восемь слов (16-битные целые числа)

| a | b | c | d | e | f | g | h |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

Или четыре двойных слова (32-битные целые числа)

| a | b | c | d |
| :---- | :---- | :---- | :---- |

Или два четверных слова (64-битные целые числа):

| a | b |
| :---- | :---- |

Резюме:

* **b**ytes (байты) - 8-битные данные  
* **w**ords (слова) - 16-битные данные  
* **d**oublewords (двойные слова) - 32-битные данные  
* **q**uadwords (четверные слова) - 64-битные данные  
* **d**ouble **q**uadwords (двойные четверные слова) - 128-битные данные

Жирные символы будут важны позже.

**Включение x86inc.asm**  
Вы увидите во многих примерах, что мы включаем файл x86inc.asm. X86inc.asm — это легкий уровень абстракции, используемый в FFmpeg, x264 и dav1d, чтобы облегчить жизнь программисту на ассемблере. Он помогает во многих отношениях, но для начала одна из полезных вещей, которую он делает, — это помечает GPR, r0, r1, r2. Это означает, что вам не нужно запоминать какие-либо имена регистров. Как упоминалось ранее, GPR обычно являются просто строительными лесами, поэтому это значительно облегчает жизнь.

**Простой скалярный фрагмент asm**

Давайте посмотрим на простой (и очень искусственный) фрагмент скалярного asm (кода на ассемблере, который работает с отдельными элементами данных, по одному за раз, в каждой инструкции), чтобы увидеть, что происходит:

```assembly
mov  r0q, 3  
inc  r0q  
dec  r0q  
imul r0q, 5
```

В первой строке *непосредственное значение* 3 (значение, хранящееся непосредственно в самом коде ассемблера, а не значение, полученное из памяти) сохраняется в регистре r0 как четверное слово. Обратите внимание, что в синтаксисе Intel исходный операнд (значение или местоположение, предоставляющее данные, расположенное справа) передается в целевой операнд (местоположение, получающее данные, расположенное слева), очень похоже на поведение memcpy. Вы также можете прочитать это как "r0q = 3", так как порядок тот же. Суффикс "q" r0 обозначает регистр как используемый в качестве четверного слова. inc увеличивает значение так, что r0q содержит 4, dec уменьшает значение обратно до 3. imul умножает значение на 5. Таким образом, в конце r0q содержит 15.

Обратите внимание, что человекочитаемые инструкции, такие как mov и inc, которые ассемблируются в машинный код ассемблером, известны как *мнемоники*. Вы можете видеть в Интернете и в книгах мнемоники, представленные заглавными буквами, такими как MOV и INC, но они такие же, как версии в нижнем регистре. В FFmpeg мы используем мнемоники в нижнем регистре и сохраняем верхний регистр зарезервированным для макросов.

**Понимание базовой векторной функции**

Вот наша первая функция SIMD:

```assembly
%include "x86inc.asm"

SECTION .text

;static void add_values(uint8_t *src, const uint8_t *src2)  
INIT_XMM sse2  
cglobal add_values, 2, 2, 2, src, src2   
    movu  m0, [srcq]  
    movu  m1, [src2q]

    paddb m0, m1

    movu  [srcq], m0

    RET
```

Давайте пройдемся по ней строка за строкой:

```assembly
%include "x86inc.asm"
```

Это "заголовок", разработанный в сообществах x264, FFmpeg и dav1d для предоставления помощников, предопределенных имен и макросов (таких как cglobal ниже) для упрощения написания ассемблера.

```assembly
SECTION .text
```

Это обозначает раздел, где размещается код, который вы хотите выполнить. Это в отличие от раздела .data, где вы можете разместить постоянные данные.

```assembly
;static void add_values(uint8_t *src, const uint8_t *src2)  
```

Первая строка — это комментарий (точка с запятой ";" в asm похожа на "//" в C), показывающий, как выглядит аргумент функции в C. Вторая строка показывает, как мы инициализируем функцию для использования регистров XMM, используя набор инструкций sse2. Это потому, что paddb — это инструкция sse2. Мы более подробно рассмотрим sse2 на следующем уроке.

```assembly
INIT_XMM sse2
```

Первая строка — это комментарий (точка с запятой ";" в asm похожа на "//" в C), показывающий, как выглядит аргумент функции в C. Вторая строка показывает, как мы инициализируем функцию для использования регистров XMM, используя набор инструкций sse2. Это потому, что paddb — это инструкция sse2. Мы более подробно рассмотрим sse2 на следующем уроке.

```assembly
cglobal add_values, 2, 2, 2, src, src2
```

Это важная строка, так как она определяет функцию C с именем "add_values".

Давайте пройдемся по каждому элементу по очереди:

* Следующий параметр показывает, что она имеет два аргумента функции.   
* Параметр после этого показывает, что мы будем использовать два GPR в этой функции, включая аргументы. В некоторых случаях мы можем захотеть использовать больше GPR, поэтому мы должны сообщить x86util, что нам нужно больше.   
* Параметр после этого говорит x86util, сколько регистров XMM мы собираемся использовать.  
* Следующие два параметра — это метки для аргументов функции.

Стоит отметить, что более старый код может не иметь меток для аргументов функции, а вместо этого обращаться к GPR напрямую, используя r0, r1 и т.д.

```assembly
    movu  m0, [srcq]  
    movu  m1, [src2q]
```

movu — это сокращение для movdqu (переместить двойное четверное слово без выравнивания). Выравнивание будет рассмотрено на другом уроке, но сейчас movu можно рассматривать как 128-битное перемещение из [srcq]. В случае mov скобки означают, что адрес в [srcq] разыменовывается, эквивалент **src в C.* Это то, что известно как загрузка. Обратите внимание, что суффикс "q" относится к размеру указателя *(т.е. в C он представляет *sizeof(*src) == 8 в 64-битных системах, и x86asm достаточно умен, чтобы использовать 32-битные в 32-битных системах), но базовая загрузка — 128-битная.

Обратите внимание, что мы не ссылаемся на векторные регистры по их полному имени, в данном случае xmm0, а как m0, абстрактная форма. В будущих уроках вы увидите, как это означает, что вы можете написать код один раз и заставить его работать на нескольких размерах регистров SIMD.

```assembly
paddb m0, m1
```

paddb (читайте это в уме как *p-add-b*) добавляет каждый байт в каждом регистре, как показано ниже. Префикс "p" означает "packed" (упакованный) и используется для идентификации векторных инструкций в отличие от скалярных инструкций. Суффикс "b" показывает, что это побайтовое сложение (сложение байтов).

| a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

\+

| q | r | s | t | u | v | w | x | y | z | aa | ab | ac | ad | ae | af |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

\=

| a+q | b+r | c+s | d+t | e+u | f+v | g+w | h+x | i+y | j+z | k+aa | l+ab | m+ac | n+ad | o+ae | p+af |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

```assembly
movu  [srcq], m0
```

Это то, что известно как сохранение. Данные записываются обратно по адресу в указателе srcq.

```assembly
RET
```

Это макрос для обозначения возврата функции. Практически все функции на ассемблере в FFmpeg изменяют данные в аргументах, а не возвращают значение.

Как вы увидите в задании, мы создаем указатели на функции для функций на ассемблере и используем их там, где они доступны.

[Следующий урок](../lesson_02/index.ru.md)
