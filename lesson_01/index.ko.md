# FFmpeg 어셈블리어 강의 1강

## 소개

FFmpeg 어셈블리어 학교에 오신걸 환영합니다. 여러분은 프로그래밍에서 가장 흥미로우면서 도전적이고 보람도 있는 여정의 첫걸음을 내디디셨습니다. 이 강의들은 FFmpeg에서 어셈블리어가 어떻게 사용되는지, 그리고 여러분들의 컴퓨터에서 실제로는 어떤 일이 일어나고 있는지 단초를 제공해줄 것입니다.

## 사전 지식

- C 언어 지식, 특히 포인터에 대한 이해가 필요합니다. 만약 아직 C에 익숙하지 않다면 [The C Programming Language](https://en.wikipedia.org/wiki/The_C_Programming_Language) 책을 참고하세요.
- 고등학교 수학 (스칼라 vs 벡터 덧셈, 곱셈 등)

## 어셈블리어란 무엇일까요?

어셈블리어는 CPU가 처리하는 명령어와 직접 대응하는 코드를 작성하는 프로그래밍 언어입니다. 사람이 읽을 수 있는 형태의 어셈블리어는 이름 그대로 '조립(assemble)'되어 CPU가 이해할 수 있는 이진 데이터, 즉 머신 코드(machine code)로 변환됩니다. 어셈블리어 코드는 종종 "어셈블리" 또는 "asm"으로 불립니다.

FFmpeg에서 사용되는 대부분의 어셈블리 코드는 단일 명령 다중 데이터 방식인 SIMD(Single Instruction Multiple Data)로 작성되어 있습니다. SIMD는 종종 벡터 프로그래밍(vector programming)이라고도 불립니다. 이 방식은 하나의 명령어가 동시에 여러 데이터 요소를 처리할 수 있게 해줍니다. 반면 대부분의 프로그래밍 언어는 한 번에 하나의 데이터만 처리하는 스칼라 프로그래밍(scalar programming) 방식입니다.

짐작하셨겠지만, SIMD는 이미지, 비디오 그리고 오디오처럼 메모리에 연속적으로 정렬된 대량의 데이터를 처리할 때 매우 효과적입니다. 이러한 순차적 데이터를 효율적으로 처리하기 위해 CPU에는 특수한 명령어들이 내장되어 있습니다.

FFmpeg에서는 "어셈블리 함수", "SIMD", "벡터화(vectorize)"라는 용어들이 혼재되어 사용되지만, 모두 여러 데이터 요소를 한 번에 처리하기 위해 어셈블리어로 직접 함수를 작성했다는 의미로 나타냅니다. 어떤 프로젝트에서는 이를 "어셈블리 커널(assembley kernel)"이라고 부르기도 합니다.

이 모든 것이 당장은 복잡하게 느껴질 수도 있지만, FFmpeg에서는 고등학생들도 어셈블리 코드를 작성했다는 점을 기억하는게 중요합니다. 어떤 것을 배우든 그 과정은 항상 절반은 용어 익히기, 나머지 절반은 실제로 이해하기입니다.

## 왜 어셈블리어를 사용하나요?

결론부터 말씀드리자면 멀티미디어를 빠르게 처리하기 위해서입니다. 어셈블리어로 작성된 코드는 10배 이상의 속도 향상을 가져오는 경향이 있으며, 특히 실시간으로 끊김 없는 영상을 재생하려는 경우에 특히 중요합니다. 추가로 에너지 소비를 줄이고 배터리 수명을 늘리는 데도 도움이 됩니다. 비디오 인코딩 및 디코딩 기능은 대기업의 데이터센터를 포함한 일반 사용자 모두에게 지구상에서 가장 많이 사용되는 기능 중 일부라는 점을 강조하고 싶습니다. 따라서 작은 개선도 빠르게 누적됩니다.

주변(online)에서는 intrinsics(내장 함수)을 사용하는걸 흔하게 볼 수 있습니다. 이는 어셈블리 명령어에 매핑되는 C 스타일 함수로, 주로 개발 속도를 높이기 위해 사용됩니다. 하지만 FFmpeg에서는 이러한 intrinsic을 사용하지 않고 어셈블리어 코드를 직접 작성합니다. 이 부분에 대해선 논쟁이 있지만, 컴파일러에 따라 일반적으로 intri은sics는 수작업으로 작성된 어셈블리 코드보다 약 10~15% 정도 느린 것으로 알려져 있습니다. FFmpeg에서는 가능한 모든 성능을 끌어내는 것이 중요하기 때문에, intrinsic에 의존하지 않는 방식을 택하고 있습니다 (옹호자들은 동의하지 않겠지만요). 또한 intrinsic은 변수에 [헝가리안 표기법](https://en.wikipedia.org/wiki/Hungarian_notation)을 사용하고 있기 때문에 읽기 어렵다는 의견도 있습니다.

또한 FFmpeg 코드 중 일부에는 역사적인 이유로 인라인 어셈블리가 남아 있는 경우가 있으며, 리눅스 커널 같은 프로젝트에서도 아주 특수한 목적을 위해 사용되곤 합니다. 인라인 어셈블리는 어셈블리어를 별도의 파일이 아닌 C 코드 내부에 직접 작성하는 방식입니다. 하지만 FFmpeg과 같은 프로젝트에서는 이런 코드가 읽기 어렵고, 컴파일러에서 널리 지원되지 않으며 유지는수가 어렵다는 것이 일반적인 견해입니다.

마지막으로 인터넷에서는 "컴파일러가 알아서 벡터화를 해주기 때문에 어셈블리어는 더 이상 필요 없다"고 주장하는 '자칭 전문가'들도 자주 볼 수 있습니다. 하지만 적어도 학습 단계에서는 신경쓰지 않아도 됩니다. 예를 들어 [dav1d 프로젝트](https://www.videolan.org/projects/dav1d.html)의 최근 테스트에서는 컴파일러의 자동 벡터화가 약 2배의 속도 향상을 보여준 반면, 수작업으로 작성한 버전은 최대 8배 까지의 성능 개선을 보여주었습니다.