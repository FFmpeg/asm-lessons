**FFmpeg 어셈블리 언어 1강**

**소개**

FFmpeg 어셈블리 언어 강좌에 오신 것을 환영합니다. 여러분은 프로그래밍에서 가장 흥미롭고, 도전적이며, 보람찬 여정의 첫 걸음을 내디뎠습니다. 이 강의들은 FFmpeg에서 어셈블리 언어가 작성되는 방식에 대한 기초를 다질 수 있게 도와주며, 컴퓨터 내부에서 실제로 어떤 일이 벌어지는지 이해할 수 있도록 도와줄 것입니다.

**필수 지식**

* C 언어 지식, 특히 포인터에 대한 이해. C를 모른다면, [The C Programming Language](https://en.wikipedia.org/wiki/The_C_Programming_Language) 책을 충분히 학습(공부)하십시오.
* 고등학교 수준의 수학 지식 (스칼라와 벡터의 차이, 덧셈, 곱셈 등)

**어셈블리 언어란 무엇인가?**

어셈블리 언어는 CPU가 처리하는 명령어에 직접적으로 대응되는 코드를 작성하는 프로그래밍 언어입니다. 사람이 읽을 수 있는 어셈블리 언어 코드는 이름 그대로 *어셈블(assembled)* 되어, CPU가 이해할 수 있는 이진 데이터인 *기계어(machine code)* 로 만들어집니다. 어셈블리 언어 코드는 흔히 "assembly" 또는 줄여서 "asm"이라고 부르기도 합니다.

FFmpeg의 어셈블리 코드 대부분은 *SIMD (Single Instruction Multiple Data, 단일 명령 다중 데이터)* 라고 불리는 방식으로 작성되어 있습니다. SIMD는 종종 벡터 프로그래밍(vector programming)이라고 불립니다. 이 방식은 하나의 명령어가 여러 데이터 요소를 동시에 처리한다는 의미입니다. 대부분의 프로그래밍 언어는 한 번에 하나의 데이터만 처리하는데, 이를 스칼라 프로그래밍(scalar programming)이라고 합니다.

예상했겠지만, SIMD는 메모리에 순차적으로 정렬된 대량의 데이터를 다루는 이미지, 비디오, 오디오 처리에 매우 적합합니다. CPU에는 이러한 순차 데이터를 효율적으로 처리하기 위한 특수 명령어들이 존재합니다.

FFmpeg에서는 "어셈블리 함수(assembly function)", "SIMD", "벡터화(vector(ise))"라는 용어가 혼용되며 동일한 개념을 의미합니다. 즉, 여러 데이터 요소를 한 번에 처리하기 위해 어셈블리 언어로 직접함수를 작성하는 것을 뜻합니다. 또한 일부 프로젝트에서는 이러한 코드를 "어셈블리 커널(assembly kernels)"이라고 부르기도 합니다.

이 모든 것이 복잡하게 들릴 수도 있지만, 기억해야 할 중요한 점은 FFmpeg에서도 실제로 고등학생들이 어셈블리 코드를 작성했다는 것입니다. 모든 학습이 그렇듯, 배우는 과정의 절반은 용어(전문 용어) 습득이고, 나머지 절반이 실제 학습(이해와 연습)입니다.

**왜 어셈블리 언어를 작성하는가?**

멀티미디어 처리를 빠르게 하기 위해서입니다. 어셈블리 코드를 작성하면 속도가 10배 이상 향상되는 경우가 흔하며, 이는 끊김 없이 부드럽게 실시간으로 비디오를 재생할 때 특히 중요합니다. 또한 에너지 소모를 줄이고 배터리 수명을 연장합니다. 비디오 인코드와 디코드 함수는 일반 사용자와 대형 기업의 데이터 센터 모두에서 전 세계적으로 가장 많이 사용되는 함수 중 하나입니다. 따라서 작은 개선점도 빠르게 큰 이점으로 이어집니다.

온라인에서는 더 빠른 개발을 위해 어셈블리 명령어로 매핑되는 C 언어 형태의 함수인 *인트린식(intrinsics)* 을 사용하는 경우를 자주 볼 수 있습니다. FFmpeg에서는 인트린식을 사용하지 않고 어셈블리 코드를 직접 작성합니다. 이것은 논란의 여지가 있는 부분이지만, 인트린식은 일반적으로 수동으로 작성된 어셈블리보다 약 10~15% 느립니다(인트린식 지지자들은 동의하지 않을 것입니다). 컴파일러에 따라 다르지만, FFmpeg에서는 가능한 모든 성능 향상이 도움이 되기 때문에 어셈블리 코드를 직접 작성합니다. 또한 인트린식은 “[헝가리안 표기법(Hungarian Notation)](https://en.wikipedia.org/wiki/Hungarian_notation)”을 사용하기 때문에 읽기 어렵다는 주장도 있습니다.

또한 FFmpeg의 일부 영역이나 Linux 커널 같은 프로젝트에서는 역사적인 이유나 매우 특정한 사용 사례로 인해 *인라인 어셈블리(inline assembly)* (즉, 인트린식을 사용하지 않는 방식)이 여전히 남아 있을 수 있습니다. 이것은 어셈블리 코드가 별도의 파일에 있지 않고 C 코드 안에 인라인으로 작성되는 경우입니다. FFmpeg과 같은 프로젝트에서는 이 코드가 읽기 어렵고, 컴파일러에서 널리 지원되지 않으며, 유지보수가 어렵다는 의견이 우세합니다.

마지막으로, 온라인에서는 자칭 전문가들이 이런 것들은 전혀 필요 없고 컴파일러가 이런 "벡터화(vectorisation)"를 모두 처리할 수 있다고 말하는 것을 자주 볼 수 있습니다. 적어도 학습의 목적에서는 그들을 무시해야 합니다. 예를 들어 [dav1d 프로젝트](https://www.videolan.org/projects/dav1d.html)의 초근 테스트에서는 이러한 자동 벡터화로 약 2배의 속도 향상을 얻었지만, 수동으로 작성된 버전은 최대 8배의 속도 향상을 보였습니다.

**어셈블리 언어의 유형**

이 강의는 x86 64비트 어셈블리 언어에 초점을 맞춥니다. 이는 amd64라고도 불리지만, 여전히 인텔 CPU에서도 작동합니다. ARM이나 RISC-V 같은 다른 CPU용 어셈블리 언어도 있으며, 향후에는 이 강의가 이러한 내용들을 다루도록 확장될 수 있습니다.

온라인에서는 두 가지 x86 어셈블리 문법 유형을 볼 수 있습니다. AT&T와 Intel 문법입니다. AT&T 문법은 더 오래되었으며, Intel 문법에 비해 읽기 어렵습니다. 따라서 우리는 Intel 문법을 사용할 것입니다.

**참고 자료**

책이나 Stack Overflow 같은 온라인 자료가 참고 자료로써 크게 도움이 되지 않는다는 점이 놀랍게 들릴 수도 있습니다. 이는 부분적으로 우리가 Intel 문법으로 직접 작성한 어셈블리를 사용하기로 한 선택 때문입니다. 또한 온라인 자료의 상당수가 운영체제 프로그래밍이나 하드웨어 프로그래밍에 초점을 맞추고 있으며, 대부분 SIMD가 아닌 코드를 사용하기 때문이기도 합니다. FFmpeg의 어셈블리는 특히 고성능 이미지 처리에 초점을 맞추고 있으며, 보시다시피 어셈블리 프로그래밍에 있어 매우 독자적인 접근 방식을 취합니다. 하지만 이 강의를 마치고 나면 다른 어셈블리 사용 사례를 이해하는 것은 쉬워집니다.

많은 책들이 어셈블리를 가르치기 전에 컴퓨터 아키텍처의 세부 내용을 깊이 다룹니다. 그것이 배우고 싶은 내용이라면 괜찮지만, 우리의 관점에서 보면 그것은 마치 운전을 배우기 전에 엔진 구조를 공부하는 것과 같습니다.

그럼에도 불구하고, "The Art of 64-bit Assembly" 책의 후반부에 나오는 SIMD 명령어와 그 동작을 시각적으로 보여주는 다이어그램은 도움이 됩니다. [https://artofasm.randallhyde.com/](https://artofasm.randallhyde.com/)

질문이 있을 경우 아래의 디스코드 서버에서 도움을 받을 수 있습니다. [https://discord.com/invite/Ks5MhUhqfB](https://discord.com/invite/Ks5MhUhqfB)

**레지스터**

레지스터는 CPU 내부에서 데이터가 처리되는 공간입니다. CPU는 메모리를 직접 다루지 않고, 데이터를 레지스터로 불러와 처리한 뒤 메모리에 되씁니다. 어셈블리 언어에서는 일반적으로 데이터를 레지스터를 거치지 않고 한 메모리 위치에서 다른 메모리 위치로 직접 복사할 수 없습니다. 

**범용 레지스터**

첫 번째 종류의 레지스터는 범용 레지스터(GPR, General Purpose Register)라고 불립니다. GPR은 일반적인 용도로 사용될 수 있기 때문에 이렇게 불리며, 데이터(여기서는 최대 64비트 값)나 메모리 주소(포인터)를 저장할 수 있습니다. GPR에 저장된 값은 덧셈, 곱셈, 시프트 등의 연산을 통해 처리될 수 있습니다.

대부분의 어셈블리 관련 책에서는 GPR의 세부적인 동작이나 역사적 배경 등을 다루는 데 여러 장을 할애합니다. 그 이유는 GPR이 운영체제 프로그래밍, 리버스 엔지니어링 등에서 중요하기 때문입니다. 하지만 FFmpeg에서 작성되는 어셈블리 코드에서는 GPR이 주로 임시적인 역할을 하며, 대부분의 경우 그 복잡한 부분은 필요하지 않거나 추상화됩니다.

**벡터 레지스터**

벡터(SIMD) 레지스터는 이름 그대로 여러 개의 데이터 요소를 포함합니다. 벡터 레지스터는 다양한 종류가 있습니다.

* mm 레지스터 - MMX 레지스터, 64비트 크기, 오래된 방식으로 현재는 거의 사용되지 않습니다.
* xmm 레지스터 - XMM 레지스터, 128비트 크기, 널리 사용됩니다.
* ymm 레지스터 - YMM 레지스터, 256비트 크기, 사용 시 약간의 복잡성이 있습니다.
* zmm 레지스터 - ZMM 레지스터, 512비트 크기, 사용 가능성이 제한적입니다.

비디오 압축과 해제의 대부분 계산은 정수 기반이므로 우리는 그에 집중할 것입니다. 다음은 xmm 레지스터 안의 16바이트 예시입니다.

| a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

하지만 워드(16비트 정수) 8개로 구성될 수도 있습니다.

| a | b | c | d | e | f | g | h |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

또는 32비트 정수(더블워드) 4개일 수도 있습니다.

| a | b | c | d |
| :---- | :---- | :---- | :---- |

혹은 64비트 정수(쿼드워드) 2개일 수도 있습니다.

| a | b |
| :---- | :---- |

요약:

* **b**ytes - 8비트 데이터
* **w**ords - 16비트 데이터 
* **d**oublewords - 32비트 데이터  
* **q**uadwords - 64비트 데이터
* **d**ouble **q**uadwords - 128비트 데이터

굵게 표시된 문자들은 이후에 중요하게 다뤄질 것입니다.

**x86inc.asm 포함 파일**

많은 예시에서 x86inc.asm 파일을 포함하는 것을 볼 수 있습니다. X86inc.asm은 FFmpeg, x264, 그리고 dav1d에서 사용되는 가벼운 추상화 레이어로, 어셈블리 프로그래머의 개발 작업을 용이하게 해줍니다. 이 파일은 여러 가지 방식으로 도움이 되지만, 우선 유용한 점 중 하나는 GPR에 r0, r1, r2와 같은 별칭(레이블)을 지정해 준다는 것입니다. 즉, 개별 레지스터 이름을 일일이 외울 필요가 없습니다. 앞서 언급했듯이, GPR은 일반적으로 보조적인 역할만 하므로, 이러한 방식은 작업을 훨씬 수월하게 해줍니다.

**간단한 스칼라 어셈블리 코드 조각**

각 명령어가 개별 데이터 항목을 한 번에 하나씩 처리하는 스칼라 어셈블리 코드의 간단한 (그리고 매우 인위적인) 예시를 살펴보겠습니다.

```assembly
mov  r0q, 3  
inc  r0q  
dec  r0q  
imul r0q, 5
```

첫 번째 줄에서는 *즉시값(immediate value)* 3(메모리에서 가져오는 값과 달리 어셈블리 코드 자체에 직접 저장된 값)이 r0 레지스터에 쿼드워드(64비트)로 저장됩니다. Intel 문법에서는 오른쪽에 있는 소스 피연산자(데이터를 제공하는 값 또는 위치)가 왼쪽에 있는 목적지 피연산자(데이터를 받는 위치)로 전달됩니다. 이는 memcpy 동작 방식과 비슷합니다. 즉, "r0q = 3"으로 읽을 수 있으며, 순서도 동일합니다. r0의 접미사 "q"는 이 레지스터가 쿼드워드로 사용됨을 나타냅니다. inc 명령은 값을 1 증가시켜 r0q가 4를 가지게 하고, dec 명령은 값을 3으로 다시 감소시킵니다. imul 명령은 값을 5배로 곱합니다. 따라서 마지막에 r0q는 15를 가지게 됩니다.

mov, inc 같은 사람이 읽을 수 있는 명령어들은 어셈블러에 의해 기계어로 변환되며, 이러한 명령어를 *니모닉(mnemonic)* 이라고 부릅니다. 온라인이나 책에서는 MOV, INC처럼 대문자로 표기된 경우를 볼 수도 있지만, 이는 소문자 버전과 동일합니다. FFmpeg에서는 소문자 니모닉을 사용하며, 대문자는 매크로를 위해 예약되어 있습니다.

**기본 벡터 함수 이해하기**

다음은 첫 번째 SIMD 함수입니다.

```assembly
%include "x86inc.asm"

SECTION .text

;static void add_values(uint8_t *src, const uint8_t *src2)  
INIT_XMM sse2  
cglobal add_values, 2, 2, 2, src, src2   
    movu  m0, [srcq]  
    movu  m1, [src2q]

    paddb m0, m1

    movu  [srcq], m0

    RET
```

한 줄씩 살펴보겠습니다.

```assembly
%include "x86inc.asm"
```

이것은 x264, FFmpeg, dav1d 커뮤니티에서 개발된 "헤더"로, 어셈블리 작성을 단순화하기 위해 헬퍼, 미리 정의된 이름, 매크로(예: 아래의 cglobal) 등을 제공합니다.

```assembly
SECTION .text
```

이 부분은 실행할 코드가 배치되는 섹션을 나타냅니다. 이는 상수 데이터를 넣는 .data 섹션과 대조됩니다.

```assembly
;static void add_values(uint8_t *src, const uint8_t *src2)  
INIT_XMM sse2
```

첫 번째 줄은 주석입니다(;은 C의 //와 같습니다). 이 줄은 C에서의 함수 인자를 보여줍니다. 두 번째 줄은 sse2 명령어 집합을 사용해 XMM 레지스터의 사용을 초기화하는 부분입니다. 이는 paddb가 sse2 명령어이기 때문입니다. sse2에 대해서는 다음 강의에서 자세히 다룹니다.

```assembly
cglobal add_values, 2, 2, 2, src, src2
```

이 줄은 "add_values"라는 C 함수를 정의하는 매우 중요한 부분입니다.

각 항목을 하나씩 살펴보면 다음과 같습니다.

* 첫 번째 인자는 함수에 두 개의 인자가 있음을 나타냅니다.
* 두 번째 인자는 인자를 포함해 두 개의 GPR을 사용할 것임을 나타냅니다. 경우에 따라 더 많은 GPR이 필요하다면 x86util에 이를 지정해야 합니다.
* 세 번째 인자는 사용할 XMM 레지스터의 수를 나타냅니다.
* 마지막 두 인자는 함수 인자의 레이블 이름입니다.

이전 코드에서는 함수 인자의 레이블이 없고, r0, r1 등의 GPR을 직접 참조하는 방식일 수도 있습니다.

```assembly
    movu  m0, [srcq]  
    movu  m1, [src2q]
```

movu는 movdqu(move double quad unaligned)의 축약형입니다. 메모리 정렬(alignment)은 이후 강의에서 다루겠지만, 지금은 [srcq]에서 128비트를 이동하는 명령으로 이해하면 됩니다. mov 명령에서 대괄호는 해당 주소를 역참조한다는 의미로, *C에서 \*src*와 같습니다. 이 동작은 로드(load)라고 합니다. q 접미사는 포인터의 크기를 나타내며(C에서 64비트 시스템의 경우 *sizeof(\*src) == 8*), x86asm은 32비트 시스템에서는 자동으로 32비트를 사용합니다. 하지만 실제 로드는 128비트 단위로 수행됩니다.

벡터 레지스터는 전체 이름(xmm0 등)으로 참조하지 않고, 추상화된 형태인 m0, m1 등으로 사용합니다. 이 방식은 이후 강의에서 볼 수 있듯이, 하나의 코드를 여러 SIMD 레지스터 크기에서도 동일하게 작동하도록 해줍니다.

```assembly
paddb m0, m1
```

paddb(머릿속으로 *p-add-b*라고 읽습니다)는 아래 예시처럼 각 레지스터의 각 바이트를 더하는 명령어입니다. 접두사 p는 "packed"를 의미하며, 벡터 명령어와 스칼라 명령어를 구분하는 데 사용됩니다. 접미사 b는 연산이 바이트 단위 덧셈임을 나타냅니다.

| a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

\+

| q | r | s | t | u | v | w | x | y | z | aa | ab | ac | ad | ae | af |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

\=

| a+q | b+r | c+s | d+t | e+u | f+v | g+w | h+x | i+y | j+z | k+aa | l+ab | m+ac | n+ad | o+ae | p+af |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

```assembly
movu  [srcq], m0
```

이 명령은 스토어(store)라고 불리며, 데이터를 srcq 포인터가 가리키는 주소로 다시 기록합니다.

```assembly
RET
```

이것은 함수가 반환함을 나타내는 매크로입니다. FFmpeg의 대부분의 어셈블리 함수는 값을 반환하는 대신 인자(파라미터) 데이터를 직접 수정합니다.

과제에서 보게 되겠지만, 우리는 어셈블리 함수에 대한 함수 포인터를 생성하고, 가능할 경우 그것을 사용하게 됩니다.

[다음 수업](../lesson_02/index.ko.md)
