# FFmpeg 어셈블리어 강의 1강

## 소개

FFmpeg 어셈블리어 학교에 오신걸 환영합니다. 여러분은 프로그래밍에서 가장 흥미로우면서 도전적이고 보람도 있는 여정의 첫걸음을 내디디셨습니다. 이 강의들은 FFmpeg에서 어셈블리어가 어떻게 사용되는지, 그리고 여러분들의 컴퓨터에서 실제로는 어떤 일이 일어나고 있는지 단초를 제공해줄 것입니다.

## 사전 지식

- C 언어 지식, 특히 포인터에 대한 이해가 필요합니다. 만약 아직 C에 익숙하지 않다면 [The C Programming Language](https://en.wikipedia.org/wiki/The_C_Programming_Language) 책을 참고하세요.
- 고등학교 수학 (스칼라 vs 벡터 덧셈, 곱셈 등)

## 어셈블리어란 무엇일까요?

어셈블리어는 CPU가 처리하는 명령어와 직접 대응하는 코드를 작성하는 프로그래밍 언어입니다. 사람이 읽을 수 있는 형태의 어셈블리어는 이름 그대로 '조립(assemble)'되어 CPU가 이해할 수 있는 이진 데이터, 즉 머신 코드(machine code)로 변환됩니다. 어셈블리어 코드는 종종 "어셈블리" 또는 "asm"으로 불립니다.

FFmpeg에서 사용되는 대부분의 어셈블리 코드는 단일 명령 다중 데이터 방식인 SIMD(Single Instruction Multiple Data)로 작성되어 있습니다. SIMD는 종종 벡터 프로그래밍(vector programming)이라고도 불립니다. 이 방식은 하나의 명령어가 동시에 여러 데이터 요소를 처리할 수 있게 해줍니다. 반면 대부분의 프로그래밍 언어는 한 번에 하나의 데이터만 처리하는 스칼라 프로그래밍(scalar programming) 방식입니다.

짐작하셨겠지만, SIMD는 이미지, 비디오 그리고 오디오처럼 메모리에 연속적으로 정렬된 대량의 데이터를 처리할 때 매우 효과적입니다. 이러한 순차적 데이터를 효율적으로 처리하기 위해 CPU에는 특수한 명령어들이 내장되어 있습니다.

FFmpeg에서는 "어셈블리 함수", "SIMD", "벡터화(vectorize)"라는 용어들이 혼재되어 사용되지만, 모두 여러 데이터 요소를 한 번에 처리하기 위해 어셈블리어로 직접 함수를 작성했다는 의미로 나타냅니다. 어떤 프로젝트에서는 이를 "어셈블리 커널(assembley kernel)"이라고 부르기도 합니다.

이 모든 것이 당장은 복잡하게 느껴질 수도 있지만, FFmpeg에서는 고등학생들도 어셈블리 코드를 작성했다는 점을 기억하는게 중요합니다. 어떤 것을 배우든 그 과정의 시작은 용어 익히기, 나머지 끝은 실제로 이해하기입니다.

## 왜 어셈블리어를 사용하나요?

결론부터 말씀드리자면 멀티미디어를 빠르게 처리하기 위해서입니다. 어셈블리어로 작성된 코드는 10배 이상의 속도 향상을 가져오는 경향이 있으며, 특히 실시간으로 끊김 없는 영상을 재생하려는 경우에 특히 중요합니다. 추가로 에너지 소비를 줄이고 배터리 수명을 늘리는 데도 도움이 됩니다. 비디오 인코딩 및 디코딩 기능은 대기업의 데이터센터를 포함한 일반 사용자 모두에게 지구상에서 가장 많이 사용되는 기능 중 일부라는 점을 강조하고 싶습니다. 따라서 작은 개선도 빠르게 누적됩니다.

주변(online)에서는 intrinsics(내장 함수)을 사용하는걸 흔하게 볼 수 있습니다. 이는 어셈블리 명령어에 매핑되는 C 스타일 함수로, 주로 개발 속도를 높이기 위해 사용됩니다. 하지만 FFmpeg에서는 이러한 intrinsic을 사용하지 않고 어셈블리어 코드를 직접 작성합니다. 이 부분에 대해선 논쟁이 있지만, 컴파일러에 따라 일반적으로 intri은sics는 수작업으로 작성된 어셈블리 코드보다 약 10~15% 정도 느린 것으로 알려져 있습니다. FFmpeg에서는 가능한 모든 성능을 끌어내는 것이 중요하기 때문에, intrinsic에 의존하지 않는 방식을 택하고 있습니다 (옹호자들은 동의하지 않겠지만요). 또한 intrinsic은 변수에 [헝가리안 표기법](https://en.wikipedia.org/wiki/Hungarian_notation)을 사용하고 있기 때문에 읽기 어렵다는 의견도 있습니다.

또한 FFmpeg 코드 중 일부에는 역사적인 이유로 인라인 어셈블리가 남아 있는 경우가 있으며, 리눅스 커널 같은 프로젝트에서도 아주 특수한 목적을 위해 사용되곤 합니다. 인라인 어셈블리는 어셈블리어를 별도의 파일이 아닌 C 코드 내부에 직접 작성하는 방식입니다. 하지만 FFmpeg과 같은 프로젝트에서는 이런 코드가 읽기 어렵고, 컴파일러에서 널리 지원되지 않으며 유지는수가 어렵다는 것이 일반적인 견해입니다.

마지막으로 인터넷에서는 "컴파일러가 알아서 벡터화를 해주기 때문에 어셈블리어는 더 이상 필요 없다"고 주장하는 '자칭 전문가'들도 자주 볼 수 있습니다. 하지만 적어도 학습 단계에서는 신경쓰지 않아도 됩니다. 예를 들어 [dav1d 프로젝트](https://www.videolan.org/projects/dav1d.html)의 최근 테스트에서는 컴파일러의 자동 벡터화가 약 2배의 속도 향상을 보여준 반면, 수작업으로 작성한 버전은 최대 8배 까지의 성능 개선을 보여주었습니다.

## 어셈블리어의 종류

이 강좌는 x86 64비트 어셈블리어를 중심으로 다룹니다. amd64라고도 하지만 인텔 CPU에서도 동일하게 동작합니다. 이 밖에도 ARM이나 RISC-V 같은 다른 CPU용 어셈블리어가 있으며, 이러한 아키텍처 까지 강의가 확장될 가능성도 있습니다.

x86 어셈블리 문법은 크게 AT&T과 Intel 두 가지 형태가 있습니다. AT&T 문법은 Intel에 비해 오래되고 읽기가 어렵기 때문에 여기서는 Intel 문법을 사용하겠습니다.

## 참고 자료

의외로 책이나 Stack Overflow 같은 온라인 자료는 참고용으로 그다지 도움이 되지 않을 수도 있습니다. 이는 부분적으로 Intel 문법을 사용한 수작업 어셈블리를 선택했기 때문이기도 하지만, 많은 온라인 자료들이 주로 운영체제나 하드웨어 프로그래밍에 초점을 맞추고 있으며, 대부분 SIMD를 사용하지 않는 코드를 다루고 있기 때문입니다. FFmpeg 어셈블리는 특히 고성능 이미지 처리에 중점을 두고 있으며, 보시게 되겠지만 어셈블리 프로그래밍에서 특히 독특한 접근 방식을 취합니다. 하지만 이 강좌를 완료하고 나면 다른 어셈블리 활용 사례들을 쉽게 이해할 수 있게 될 것입니다.

많은 책들이 어셈블리를 가르치기 전에 컴퓨터 아키텍처에 대한 세부 사항을 자세히 다룹니다. 그런 것을 배우고 싶다면 괜찮지만, 우리 관점에서는 자동차 운전을 배우기 전에 엔진을 공부하는 것과 같습니다.

하지만 "The Art of 64-bit assembly" 책의 후반부에 나오는 다이어그램들은 도움이 됩니다. 이 다이어그램들은 SIMD 명령어들과 그 동작을 시각적으로 보여줍니다: https://artofasm.randallhyde.com/

질문을 할 수 있는 디스코드 서버도 운영되고 있습니다: https://discord.com/invite/Ks5MhUhqfB

## 레지스터 (Register)

레지스터는 CPU 내부에서 데이터를 처리하는 영역입니다. CPU는 메모리를 직접 연산하지 않고, 먼저 데이터를 레지스터로 불러온(load) 뒤 처리하고, 다시 메모리에 기록하는 방식으로 동작합니다. 어셈블리어에서는 일반적으로 한 메모리 위치에서 다른 메모리 위치로 데이터를 바로 복사할 수 없으며, 반드시 레지스터를 거쳐야 합니다.

## 범용 레지스터(General Purpose Register)

첫 번째 종류의 레지스터는 범용 레지스터(GPR, General Purpose Register)라고 불립니다. '범용'이라는 이름은 이 레지스터가 데이터(최대 64비트 값)나 메모리 주소(포인터)를 모두 담을 수 있기 때문에 붙었습니다. GPR에 들어 있는 값은 덧셈, 곱셈, 시프트(shift) 등의 연산을 통해 처리할 수 있습니다.

대부분의 어셈블리 관련 서적에서는 GPR의 세부 동작 방식이나 역사적 배경 등에 대해 지면을 할애해 다룹니다. 이는 운영체제 프로그래밍이나 리버스 엔지니어링처럼 GPR이 중요한 분야가 있기 때문입니다. 그러나 FFmpeg에서 작성하는 대부분은 어셈블리 코드는 GPR은 보조적인 역할(scaffolding)에 가깝기 때문에 복잡한 세부 기능이 필요하지 않은 경우가 많아 대부분 추상화 되어 있습니다.

## 벡터 레지스터 (Vector Register)

벡터(SIMD) 레지스터는 이름 그대로 여러 개의 데이터 요소를 담을 수 있는 레지스터입니다. 이 레지스터에는 여러 종류가 있습니다.

- **mm 레지스터**: MMX 레지스터, 64비트 크기, 현재는 잘 사용되지 않음
- **xmm 레지스터**: XMM 레지스터, 128비트 크기, 널리 사용됨
- **ymm 레지스터**: YMM 레지스터, 256비트 크기, 사용 시 몇 가지 제약이 있음
- **zmm 레지스터**: ZMM 레지스터, 512비트 크기, 사용 가능 환경이 제한적임

비디오 압축과 압축 해제에서 대부분의 연산은 정수 기반이므로 여기서는 정수 데이터를 기준으로 설명하겠습니다.

다음은 xmm 레지스터에 담긴 16바이트의 예시입니다.

| a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

하지만 8개의 워드(16비트 정수)가 될 수도 있습니다.

| a | b | c | d | e | f | g | h |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

또는 4개의 더블워드(32비트 정수)의 형태로도

| a | b | c | d |
| :---- | :---- | :---- | :---- |

아니면 2개의 쿼드워드(64비트 정수)가 될 수 있습니다.

| a | b |
| :---- | :---- |

정리하면 다음과 같습니다. 굵게 표시한 글자는 이후에도 중요하게 사용됩니다.

- **b**ytes - 8비트 데이터
- **w**ords - 16비트 데이터
- **d**oublewords - 32비트 데이터
- **q**uadwords - 64비트 데이터
- **d**ouble **q**uadwords - 128비트 데이터
