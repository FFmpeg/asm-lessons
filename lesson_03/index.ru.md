**Урок третий по языку ассемблера FFmpeg**

Давайте объясним еще немного жаргона и дадим вам краткий исторический урок.

**Наборы инструкций**

Возможно, вы видели в предыдущем уроке, что мы говорили о SSE2, который является набором SIMD инструкций. Когда выпускается новое поколение процессора, оно может поставляться с новыми инструкциями и иногда с регистрами большего размера. История набора инструкций x86 очень сложна, поэтому это упрощенная история (существует намного больше подкategorий):

* MMX - Запущен в 1997 году, первый SIMD в процессорах Intel, 64-битные регистры, исторический
* SSE (Streaming SIMD Extensions) - Запущен в 1999 году, 128-битные регистры
* SSE2 - Запущен в 2000 году, много новых инструкций
* SSE3 - Запущен в 2004 году, первые горизонтальные инструкции
* SSSE3 (Supplemental SSE3) - Запущен в 2006 году, новые инструкции, но самое важное - инструкция перемешивания pshufb, возможно, самая важная инструкция в обработке видео
* SSE4 - Запущен в 2008 году, много новых инструкций, включая упакованные минимум и максимум
* AVX - Запущен в 2011 году, 256-битные регистры (только float) и новый синтаксис с тремя операндами
* AVX2 - Запущен в 2013 году, 256-битные регистры для целочисленных инструкций
* AVX512 - Запущен в 2017 году, 512-битные регистры, новая функция операционной маски. Они имели ограниченное использование в то время в FFmpeg из-за снижения частоты процессора при использовании новых инструкций. Полное 512-битное перемешивание (перестановка) с vpermb.
* AVX512ICL - Запущен в 2019 году, больше нет снижения тактовой частоты
* AVX10 - Предстоящий

Стоит отметить, что наборы инструкций могут быть удалены так же, как и добавлены в процессоры. Например, AVX512 был [удален](https://www.igorslab.de/en/intel-deactivated-avx-512-on-alder-lake-but-fully-questionable-interpretation-of-efficiency-news-editorial/), что вызвало споры, в процессорах Intel 12-го поколения. По этой причине FFmpeg выполняет обнаружение возможностей процессора во время выполнения. FFmpeg обнаруживает возможности процессора, на котором он запущен.

Как вы видели в задании, указатели на функции являются C по умолчанию и заменяются конкретным вариантом набора инструкций. Это означает, что обнаружение выполняется один раз и затем никогда больше не требуется. Это в отличие от многих проприетарных приложений, которые жестко кодируют конкретный набор инструкций, делая совершенно функциональный компьютер устаревшим. Это также позволяет включать/выключать оптимизированные функции во время выполнения. Это одно из больших преимуществ открытого исходного кода.

Программы, такие как FFmpeg, используются на миллиардах устройств по всему миру, некоторые из которых могут быть очень старыми. FFmpeg технически поддерживает машины, поддерживающие только SSE, которым 25 лет! К счастью, x86inc.asm способен сообщить вам, если вы используете инструкцию, которая недоступна в конкретном наборе инструкций.

Чтобы дать вам представление о реальных возможностях, вот доступность набора инструкций из [Steam Survey](https://store.steampowered.com/hwsurvey/Steam-Hardware-Software-Survey-Welcome-to-Steam) на ноябрь 2024 года (это, очевидно, смещено в сторону геймеров):

| Набор инструкций | Доступность |
| :---- | :---- |
| SSE2 | 100% |
| SSE3 | 100% |
| SSSE3 | 99.86% |
| SSE4.1 | 99.80% |
| AVX | 97.39% |
| AVX2 | 94.44% |
| AVX512 (Steam не разделяет между AVX512 и AVX512ICL) | 14.09% |

Для такого приложения, как FFmpeg с миллиардами пользователей, даже 0.1% - это очень большое количество пользователей и сообщений об ошибках, если что-то ломается. FFmpeg имеет обширную инфраструктуру тестирования для проверки вариаций ЦП/ОС/Компилятор в нашем [тестовом наборе FATE](https://fate.ffmpeg.org/?query=subarch:x86_64%2F%2F). Каждый отдельный коммит запускается на сотнях машин, чтобы убедиться, что ничего не ломается.

Intel предоставляет подробное руководство по набору инструкций здесь: [https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)

Поиск по PDF может быть громоздким, поэтому есть неофициальная веб-альтернатива здесь: [https://www.felixcloutier.com/x86/](https://www.felixcloutier.com/x86/)

Также доступно визуальное представление SIMD инструкций здесь:
[https://www.officedaytime.com/simd512e/](https://www.officedaytime.com/simd512e/)

Часть вызова ассемблера x86 заключается в поиске правильной инструкции для ваших нужд. В некоторых случаях инструкции могут использоваться способом, для которого они изначально не предназначались.

**Трюк со смещением указателя**

Давайте вернемся к нашей оригинальной функции из Урока 1, но добавим аргумент width к функции C.

Мы используем ptrdiff_t для переменной width вместо int, чтобы убедиться, что верхние 32 бита 64-битного аргумента равны нулю. Если бы мы напрямую передали int width в сигнатуре функции, а затем попытались бы использовать его как quad для арифметики указателей (т.е. используя `widthq`), верхние 32 бита регистра могли бы быть заполнены произвольными значениями. Мы могли бы исправить это, расширив знак width с помощью `movsxd` (также см. макрос `movsxdifnidn` в x86inc.asm), но это более простой способ.

Функция ниже содержит трюк со смещением указателя:

```assembly
;static void add_values(uint8_t *src, const uint8_t *src2, ptrdiff_t width)
INIT_XMM sse2
cglobal add_values, 3, 3, 2, src, src2, width
   add srcq, widthq
   add src2q, widthq
   neg widthq

.loop
    movu  m0, [srcq+widthq]
    movu  m1, [src2q+widthq]

    paddb m0, m1

    movu  [srcq+widthq], m0
    add   widthq, mmsize
    jl .loop

    RET
```

Давайте пройдем через это шаг за шагом, поскольку это может сбивать с толку:

```assembly
   add srcq, widthq
   add src2q, widthq
   neg widthq
```

Ширина добавляется к каждому указателю таким образом, что каждый указатель теперь указывает на конец буфера, который должен быть обработан. Затем ширина инвертируется.

```assembly
    movu  m0, [srcq+widthq]
    movu  m1, [src2q+widthq]
```

Загрузки затем выполняются с widthq, являющимся отрицательным. Таким образом, на первой итерации [srcq+widthq] указывает на исходный адрес srcq, т.е. указывает обратно на начало буфера.

```assembly
    add   widthq, mmsize
    jl .loop
```

mmsize добавляется к отрицательному widthq, приближая его к нулю. Условие цикла теперь jl (переход, если меньше нуля). Этот трюк означает, что widthq используется как смещение указателя **и** как счетчик цикла одновременно, экономя инструкцию cmp. Это также позволяет использовать смещение указателя в нескольких загрузках и сохранениях, а также использовать кратные смещения указателей при необходимости (запомните это для задания).

**Выравнивание**

Во всех наших примерах мы использовали movu, чтобы избежать темы выравнивания. Многие процессоры могут загружать и сохранять данные быстрее, если данные выровнены, т.е. если адрес памяти делится на размер SIMD регистра. Где это возможно, мы стараемся использовать выровненные загрузки и сохранения в FFmpeg, используя mova.

В FFmpeg av_malloc может предоставить выровненную память в куче, а директива препроцессора C DECLARE_ALIGNED может предоставить выровненную память в стеке. Если mova используется с невыровненным адресом, это вызовет ошибку сегментации, и приложение аварийно завершится. Также важно убедиться, что значение выравнивания соответствует размеру SIMD регистра, т.е. 16 с xmm, 32 для ymm и 64 для zmm.

Вот как выровнять начало секции RODATA на 64 байта:

```assembly
SECTION_RODATA 64
```

Обратите внимание, что это выравнивает только начало RODATA. Могут потребоваться байты заполнения, чтобы убедиться, что следующая метка остается на 64-байтовой границе.

**Расширение диапазона**

Другая тема, которую мы избегали до сих пор, - это переполнение. Это происходит, например, когда значение байта превышает 255 после операции, такой как сложение или умножение. Мы можем захотеть выполнить операцию, где нам нужно промежуточное значение больше байта (например, слова), или потенциально мы хотим оставить данные в этом большем промежуточном размере.

Для беззнаковых байтов именно здесь появляются punpcklbw (упакованная распаковка младших байтов в слова) и punpckhbw (упакованная распаковка старших байтов в слова).

Давайте посмотрим, как работает punpcklbw. Синтаксис для версии SSE2 из руководства Intel выглядит следующим образом:

| PUNPCKLBW xmm1, xmm2/m128 |
| :---- |

Это означает, что его источник (правая сторона) может быть xmm регистром или адресом памяти (m128 означает адрес памяти со стандартным синтаксисом [base + scale*index + disp]), а назначением - xmm регистр.

Веб-сайт officedaytime.com выше имеет хорошую диаграмму, показывающую, что происходит:

![What is this](image1.png)

Вы можете видеть, что байты чередуются из нижней половины каждого регистра соответственно. Но какое отношение это имеет к расширению диапазона? Если регистр src состоит из всех нулей, это чередует байты в dst с нулями. Это то, что известно как *расширение нулем*, поскольку байты беззнаковые. punpckhbw может использоваться для того же самого со старшими байтами.

Вот фрагмент, показывающий, как это делается:

```assembly
pxor      m2, m2 ; обнулить m2

movu      m0, [srcq]
movu      m1, m0 ; сделать копию m0 в m1
punpcklbw m0, m2
punpckhbw m1, m2
```

```m0``` и ```m1``` теперь содержат исходные байты, расширенные нулем до слов. В следующем уроке вы увидите, как инструкции с тремя операндами в AVX делают второй movu ненужным.

**Расширение знака**

Знаковые данные немного сложнее. Для расширения диапазона знакового целого числа нам нужно использовать процесс, известный как [расширение знака](https://en.wikipedia.org/wiki/Sign_extension). Это заполняет MSB знаковым битом. Например: -2 в int8_t равно 0b11111110. Для расширения знака до int16_t MSB 1 повторяется, чтобы получить 0b1111111111111110.

```pcmpgtb``` (упакованное сравнение больше чем байт) может использоваться для расширения знака. Выполняя сравнение (0 > байт), все биты в байте назначения устанавливаются в 1, если байт отрицательный, иначе биты в байте назначения устанавливаются в 0. punpckX может использоваться, как указано выше, для выполнения расширения знака. Если байт отрицательный, соответствующий байт равен 0b11111111, иначе это 0x00000000. Чередование значения байта с выводом pcmpgtb выполняет расширение знака до слова в результате.

```assembly
pxor      m2, m2 ; обнулить m2

movu      m0, [srcq]
movu      m1, m0 ; сделать копию m0 в m1

pcmpgtb   m2, m0
punpcklbw m0, m2
punpckhbw m1, m2
```

Как вы можете видеть, есть дополнительная инструкция по сравнению с беззнаковым случаем.

**Упаковка**

packuswb (упаковка беззнакового слова в байт) и packsswb позволяют вам перейти от слова к байту. Это позволяет вам чередовать два SIMD регистра, содержащих слова, в один SIMD регистр с байтом. Обратите внимание, что если значения превышают диапазон байта, они будут насыщены (т.е. ограничены наибольшим значением).

**Перемешивания**

Перемешивания, также известные как перестановки, возможно, являются самой важной инструкцией в обработке видео, а pshufb (упакованное перемешивание байтов), доступное в SSSE3, является самым важным вариантом.

Для каждого байта соответствующий исходный байт используется как индекс регистра назначения, за исключением случаев, когда MSB установлен, байт назначения обнуляется. Это аналогично следующему коду C (хотя в SIMD все 16 итераций цикла происходят параллельно):

```c
for(int i = 0; i < 16; i++) {
    if(src[i] & 0x80)
        dst[i] = 0;
    else
        dst[i] = dst[src[i]]
}
```
Вот простой пример ассемблера:

```assembly
SECTION_DATA 64

shuffle_mask: db 4, 3, 1, 2, -1, 2, 3, 7, 5, 4, 3, 8, 12, 13, 15, -1

section .text

movu m0, [srcq]
movu m1, [shuffle_mask]
pshufb m0, m1 ; перемешать m0 на основе m1
```

Обратите внимание, что -1 для удобства чтения используется как индекс перемешивания для обнуления выходного байта: -1 как байт является битовым полем 0b11111111 (дополнение до двух), и таким образом MSB (0x80) установлен.